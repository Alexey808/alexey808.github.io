
### БАЗОВОЕ ###
// --- Простая функция. --------------------------------------------------------------------------+
// --- Простая функция но уже с параметрами и возращением. ---------------------------------------+
// --- Анонимная функция. ------------------------------------------------------------------------+
// --- Строчная фкнция. --------------------------------------------------------------------------+
// --- Рекурсия. ---------------------------------------------------------------------------------+
// --- Замыкания. --------------------------------------------------------------------------------+
// --- Функция-констурктор, Функциональный стиль и портотипный вариант. --------------------------+

  // --- Простая функция. --------------------------------------------------------------------------+
    // 1) Function Declaration //рекомендуется
    function fname() {
      alert( 'Привет всем присутствующим!' );
    }

    // 2) Function Expression
    var fname = function() {
      alert( 'Привет всем присутствующим!' );
    }

  // --- Простая функция но уже с параметрами и возращением. ---------------------------------------+
    function fname(a, b) {
      return a + b;
    }
    var a = 5;
    var b = 10;
    alert ( fname(a, b) ); //где "fname(a, b)" вызов функции

  // --- Анонимная функция. ------------------------------------------------------------------------+
    (function () { 
      alert ("Анонимная функция")
    })(); // где последнее () это вызов анонимной функции
    //-
    +function() {
      alert('Вызов на месте');
    }();
    //-
    !function() {
      alert('Так тоже будет работать');
    }();
    //-
    var timerId = setTimeout(function() { alert(1) }, 1000); 
    clearTimeout(timerId);
    
  // --- Строчная фкнция. --------------------------------------------------------------------------+
    var sum = new Function('a,b', ' return a+b; ');
    var result = sum(1, 2);
    alert( result ); // 3

  // --- Рекурсия. ---------------------------------------------------------------------------------+
    function factorial(num) {
      // Если число меньше 0, отклонить его.
      if (num < 0) {
          return -1;
      }
      // Если число равно 0, то его факториал 1.
      else if (num == 0) {
          return 1;
      }
      // В противном случае, вызовите эту рекурсивную процедуру снова.
      else {
        return (num * factorial(num - 1));
      }
    }
    var result = factorial(8);
    console.log( result ); //40320

  // --- Замыкания. --------------------------------------------------------------------------------+
    function sum (a) {

      return function(b) {
        return a + b;
      }
    }

    console.log( sum(1)(2) ); // 3

  // --- Функция-констурктор, Функциональный стиль и портотипный вариант. --------------------------+

    //Функциональный стиль-----------------------------------------------
      function Animal(name) {
        this.speed = 0;
        this.name = name;

        this.run = function(speed) {
          this.speed += speed;
          alert( this.name + ' бежит, скорость ' + this.speed );
        };

        this.stop = function() {
          this.speed = 0;
          alert( this.name + ' стоит' );
        };
      };

      var animal = new Animal('Зверь');

      alert( animal.speed ); // 0, начальная скорость
      animal.run(3); // Зверь бежит, скорость 3
      animal.run(10); // Зверь бежит, скорость 13
      animal.stop(); // Зверь стоит

    //Портотипный--------------------------------------------------------
      function Animal(name) {
        this.name = name;
        this.speed = 0;
      }

      Animal.prototype.run = function(speed) {
        this.speed += speed;
        alert( this.name + ' бежит, скорость ' + this.speed );
      };

      Animal.prototype.stop = function() {
        this.speed = 0;
        alert( this.name + ' стоит' );
      };

      var animal = new Animal('Зверь');

      alert( animal.speed ); // 0, свойство взято из прототипа
      animal.run(5); // Зверь бежит, скорость 5
      animal.run(5); // Зверь бежит, скорость 10
      animal.stop(); // Зверь стоит

### ES6 ###

!У функций появилось свойство name.

//--- Стрелочные функции, синтакс. ---------------------------------------------------------------+
//--- Значения по умолчанию примитиф/функция. ----------------------------------------------------+
//--- Оператор spread он же ... | Остаточные параметры. ------------------------------------------+
//--- Деструктуризация. --------------------------------------------------------------------------+
//--- Стрелочная функция | Один аргумент. --------------------------------------------------------+
//--- Стрелочная функция | Несколько аргументов. -------------------------------------------------+
//--- Стрелочная функция | Без рагументов. -------------------------------------------------------+
//--- Стрелочная функция | Большое тело функции. -------------------------------------------------+
//--- Стрелочная функция | Удобное испльзования в коллбеках. -------------------------------------+
//--- Стрелочная функция | Декоратор с => и без =>. ----------------------------------------------+

  //--- Стрелочные функции, синтакс. ---------------------------------------------------------------+
  	
    // Основной синтаксис:
  	(param1, param2, paramN) => { statements }
  	(param1, param2, paramN) => expression
  	   // Эквивалентно:  => { return expression; }

  	// Скобки не являются обязательными, когда есть только один аргумент:
  	(singleParam) => { statements }
  	singleParam => { statements }

  	// Функция без аргументов требует круглых скобок:
  	() => { statements }

  	// Дополнительно:
  	// Тело круглые скобки, чтобы вернуть буквальное выражение объекта:
  	params => ({foo: bar})

  	// Остаточные параметры поддерживаются
  	(param1, param2, ...rest) => { statements }

  //--- Значения по умолчанию примитиф/функция. ----------------------------------------------------+
  	function showMenu(
  		title = "Без заголовка", 
  		width = 100, 
  		height = 200, 
  		who = getCurrentUser().toUpperCase()) {

  	  	console.log(title + ' ' + width + ' ' + height  + ' ' + who);
  	}

  	function getCurrentUser() {
  	  return 'Васено-меню';
  	}

  	showMenu("Меню"); // Меню 100 200 ВАСЕНО-МЕНЮ

  //--- Оператор spread он же ... | Остаточные параметры. ------------------------------------------+
  	let numbers = [2, 3, 15];
  	// Этот вызов аналогичен Math.max(2, 3, 15)
  	let max = Math.max(...numbers);
  	alert( max ); // 15

  //--- Деструктуризация. --------------------------------------------------------------------------+
  	//весь объект аргументов по умолчанию равен пустому объекту {}, 
    //поэтому всегда есть что деструктуризовать.
  	function showMenu({title="Заголовок", width:w=100, height:h=200} = {}) {
  	  alert(title + ' ' + w + ' ' + h);
  	}
  	showMenu(); // Заголовок 100 200

  //--- Стрелочная функция | Один аргумент. --------------------------------------------------------+
  	let inc = x => x+1; 		//let inc = function(x) { return x + 1; };
  	console.log(inc(1)); 		//2

  //--- Стрелочная функция | Несколько аргументов. -------------------------------------------------+
  	let sum = (a,b) => a + b; 	//let inc = function(a, b) { return a + b; };
  	console.log(sum(1,2));		//3

  //--- Стрелочная функция | Без рагументов. -------------------------------------------------------+
  	let getTime = () => new Date().getHours() + ':' + new Date().getMinutes();
  	alert( getTime() ); 		// текущее время

  //--- Стрелочная функция | Большое тело функции. -------------------------------------------------+
  	let getTime = () => {
  	  let date = new Date();
  	  let hours = date.getHours();
  	  let minutes = date.getMinutes();
  	  return hourse + ':' + minutes; //уже нужно возвратить
  	};
  	alert( getTime() ); // текущее время	

  //--- Стрелочная функция | Удобное испльзования в коллбеках. -------------------------------------+
  	let arr = [5, 8, 3];
  	let sorted = arr.sort( (a,b) => a - b );
  	alert(sorted); // 3, 5, 8

  //--- Стрелочная функция | Декоратор с => и без =>. ----------------------------------------------+
  	//c =>---------------------------
  		function defer(f, ms) {
  		  return function() {
  		    setTimeout(() => f.apply(this, arguments), ms)
  		  }
  		}

  		function sayHi(who) {
  		  alert('Привет, ' + who);
  		}

  		let sayHiDeferred = defer(sayHi, 2000);
  		sayHiDeferred("Вася"); // Привет, Вася через 2 секунды

  	//без =>-------------------------
  		function defer(f, ms) {
  		  return function() {
  		    let args = arguments;
  		    let ctx = this;
  		    setTimeout(function() {
  		      return f.apply(ctx, args);
  		    }, ms);
  		  }
  		}

  		function sayHi(who) {
  		  alert('Привет, ' + who);
  		}

  		let sayHiDeferred = defer(sayHi, 2000);
  		sayHiDeferred("Вася"); // Привет, Вася через 2 секунды


# ES6-Генераторы #
//--- Функция-генератор, синтакс. ----------------------------------------------------------------+
//--- Фкнция-генератор | yield. ------------------------------------------------------------------+
//--- Пример 1. Генератора. ----------------------------------------------------------------------+
//--- Перебор генератора. ------------------------------------------------------------------------+
//--- Композиция генераторов. --------------------------------------------------------------------+
//--- Использование возварённые значения для генератора. -----------------------------------------+
//--- Перехват ошибок в генераторах. generator.throw. --------------------------------------------+
//--- Генератор+промис. --------------------------------------------------------------------------+
//=== Генераторы+промисы+со(это библиотека). ===================================================--+
//--- Перехват ошибок в со. ----------------------------------------------------------------------+
//--- со+композиция_генераторов. -----------------------------------------------------------------+

  //--- Функция-генератор, синтакс. ----------------------------------------------------------------+
    function* [имя]([параметр1[, параметр2[, ..., параметрN]]]) {
       инструкции
    }

  //--- Фкнция-генератор | yield. ------------------------------------------------------------------+
  var x = function*(y) {
     yield y * y;
  };

  //--- Пример 1. Генератора. ----------------------------------------------------------------------+
    function* generateSequence() {
      yield 1;  //1)
      yield 2;  //2)
      return 3; //3)
    }
    // generator function создаёт generator
    let generator = generateSequence();
    // 1)
    let one = generator.next();
    alert(JSON.stringify(one));     // {value: 1, done: false} 
    // 2)
    let two = generator.next();
    alert(JSON.stringify(two));     // {value: 2, done: false}
    // 3)
    let three = generator.next();
    alert(JSON.stringify(three));   // {value: 3, done: true}

  //--- Перебор генератора. ------------------------------------------------------------------------+
    /*отсутствие return в переборе генератора for..of – в некотором смысле «исключение».*/
    function* generateSequence() {
      yield 1;
      yield 2;
      //return 3; // при переборе value на последнем значении игнорируется, исп yield
      yield 3;
    }

    let generator = generateSequence();

    for(let value of generator) {
      alert(value); // 1 затем 2 затем 3
    }

  //--- Композиция генераторов. --------------------------------------------------------------------+
    /*Здесь использована специальная форма yield*. Она применима только к другому генератору и 
      делегирует ему выполнение.*/

    function* generateSequence(start, end) {
      for (let i = start; i <= end; i++) yield i;
    }

    function* generateAlphaNum() {

      // 0..9
      yield* generateSequence(48, 57); //аналогично: for (let i = 48; i <= 57; i++) yield i;

      // A..Z
      yield* generateSequence(65, 90); //аналогично: for (let i = 65; i <= 90; i++) yield i;

      // a..z
      yield* generateSequence(97, 122); //аналогично: for (let i = 97; i <= 122; i++) yield i;

    }

    let str = '';

    for(let code of generateAlphaNum()) {
      str += String.fromCharCode(code);
    }

    alert(str); // 0..9A..Za..z

  //--- Использование возварённые значения для генератора. -----------------------------------------+
    /*Вызов let result = yield value делает следующее:
    1) Возвращает value во внешний код, приостанавливая выполнение генератора.
    2) Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).
    3) Генератор продолжит выполнение, аргумент next будет возвращён как результат yield (и записан в result).*/
        
    function* gen() {
      let ask1 = yield "Сколько будет 2 + 2?";

      alert(ask1); // 4

      let ask2 = yield "3 * 3?"

      alert(ask2); // 9
    }

    let generator = gen();

    alert( generator.next().value ); // "2 + 2?"

    alert( generator.next(4).value ); // "3 * 3?"

    alert( generator.next(9).done ); // true

    /*каждый next(value) передаёт в генератор значение, которое становится результатом текущего 
    yield, возобновляет выполнение и получает выражение из следующего yield. Исключением является 
    первый вызов next, который не может передать значение в генератор, т.к. ещё не было ни 
    одного yield.*/

  //--- Перехват ошибок в генераторах. generator.throw. --------------------------------------------+
    
    //Пример 1. Перехват в генераторе --------------------------------------------------------------
      function* gen() {
        try {
          // в этой строке возникнет ошибка
          let result = yield "Сколько будет 2 + 2?"; // (**)

          alert("выше будет исключение ^^^");
        } catch(e) {
          alert(e); // выведет ошибку
        }
      }

      let generator = gen();

      let question = generator.next().value;

      generator.throw(new Error("ответ не найден в моей базе данных")); // (*)

    //Пример 2. Перехват снаружи -------------------------------------------------------------------
      /*Если ошибку не перехватить, то она «выпадет» из генератора. По стеку ближайший вызов, 
        который инициировал выполнение – это строка с .throw.*/
      function* gen() {
        // В этой строке возникнет ошибка
        let result = yield "Сколько будет 2 + 2?";
      }

      let generator = gen();

      let question = generator.next().value;

      try {
        generator.throw(new Error("ответ не найден в моей базе данных"));
      } catch(e) {
        alert(e); // выведет ошибку
      }

  //--- Генератор+промис. --------------------------------------------------------------------------+
    /*Функция execute в примере выше – универсальная, она может работать с любым генератором, 
      который yield'ит промисы.*/

    // генератор для получения и показа аватара
    // он yield'ит промисы
    function* showUserAvatar() {

      let userFetch = yield fetch('/article/generator/user.json');
      let userInfo = yield userFetch.json();

      let githubFetch = yield fetch(`https://api.github.com/users/${userInfo.name}`);
      let githubUserInfo = yield githubFetch.json();

      let img = new Image();
      img.src = githubUserInfo.avatar_url;
      img.className = "promise-avatar-example";
      document.body.appendChild(img);

      yield new Promise(resolve => setTimeout(resolve, 3000));

      img.remove();

      return img.src;
    }

    // Универсальная вспомогательная функция-чернорабочий
    // для выполнения промисов из generator
    function execute(generator, yieldValue) {

      let next = generator.next(yieldValue);

      if (!next.done) {
        next.value.then(
          result => execute(generator, result),
          err => generator.throw(err)
        );
      } else {
        // обработаем результат return из генератора
        // обычно здесь вызов callback или что-то в этом духе
        alert(next.value);
      }

    }

    execute( showUserAvatar() );
  
  //=== Генераторы+промисы+со(это библиотека). ===================================================--+
    /*!!!При работе с библиотекой со обязательно нужен перехватчик ошибок catch*/
    /*Предпологается что библиотека со уже подключенна*/
    co(function*() {

      let result = yield new Promise(
        resolve => setTimeout(resolve, 1000, 1)
      );

      return result; // return 1

    }).then(alert); // 1

  //--- Перехват ошибок в со. ----------------------------------------------------------------------+
    co(function*() {
      throw new Error("Sorry that happened");
    }).catch(alert); // обработать ошибку как-либо  

      //Возможности библиотеки со
    Object.defineProperty(window, 'result', {
      // присвоение result=… будет выводить значение
      set: value => alert(JSON.stringify(value))
    });

    co(function*() {
      result = yield function*() { // генератор
        return 1;
      }();

      result = yield function*() { // функция-генератор
        return 2;
      };

      result = yield Promise.resolve(3); // промис

      result = yield function(callback) { // function(callback) // Устарели! надо исп промисы
        setTimeout(() => callback(null, 4), 1000);
      };

      result = yield { // две задачи выполнит параллельно, как Promise.all
        one: Promise.resolve(1),
        two: function*() { return 2; }
      };

      result = yield [ // две задачи выполнит параллельно, как Promise.all
        Promise.resolve(1),
        function*() { return 2 }
      ];

    }); 

  //--- со+композиция_генераторов. -----------------------------------------------------------------+
    
    //Пример 1. Композиция. Аналогичен примеру 2, тот не копозиция.-
      co(function*() {
        let result = yield* gen();
        alert(result); // hello
      });

      function* gen() {
        return yield* gen2();
      }

      function* gen2() {
        let result = yield new Promise( // (1)
          resolve => setTimeout(resolve, 1000, 'hello')
        );
        return result;
      }
    
    //Пример 2. ----------------------------------------------------
      co(function*() {
        let result = yield new Promise(
          resolve => setTimeout(resolve, 1000, 'hello')
        );
        alert(result); // hello
      });

