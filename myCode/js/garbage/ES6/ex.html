!ТУТ РАЗОБРАЛ

<!DOCTYPE html>
<html>
<head>
	<title>ES6</title>
</head>
<body>
Библиотека: 
	со - https://github.com/tj/co и https://cdnjs.com/libraries/co/
	Эта библиотека может обрабатывать следующее:
		1) Промис.
		2) Объект-генератор.
		3) Функция-генератор function*() – co её выполнит, затем выполнит полученный генератор.
		4) Функция с единственным аргументом вида function(callback) – библиотека co её запустит со 
			 своей функцией-callback и будет ожидать, что при ошибке она вызовет callback(err), а при 
			 успешном выполнении – callback(null, result). То есть, в первом аргументе – будет ошибка 
			 (если есть), а втором – результат (если нет ошибки). После чего результат будет передан 
			 в генератор.
		5) Массив или объект из вышеперечисленного. При этом все задачи будут выполнены параллельно, и 
		результат, в той же структуре, будет выдан наружу.

Словарик:
	Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.
	интерполяцией - вставка кода в код

Переменные:
	let - вместо var. Имеет локальную область видимости.
	const - для относительных констант и КОНСТАНТ

Операторы 
	spread - он же ... позволяет получить остаток массива. Должно находится в конце.


### СОДЕРЖАНИЕ ###

	Переменная let ===================================================================================

	Деструктуризация =================================================================================
		# Заметки:
			!Чтобы избежать интерпретации {a, b} нужно обернуть всё присваивание в скобки.
			---
		------------------------------------------------------------------------------------------------
		+ Отбрасывания элементов
		+ Оператор spread он же ... позволяет получить остаток массива
		+ Значения по умолчанию в массиве через let через =
		+ Деструктуризации массива
		+ Деструктуризация объекта
		+ Деструктуризация объекта со вложенными объектами и массивами

	Функции ==========================================================================================
		# Заметки:
			!Внутри функций-стрелок – тот же this, что и снаружи, поэтому функции стрелки нельзя запускать с new.
			!Функции-стрелки не имеют своего arguments.
		------------------------------------------------------------------------------------------------
		+ Параметры по умолчанию
		+ Оператор spread вместо arguments
		+ Деструктуризация в параметрах
		+ Имя "name"
		+ Функции через => 

	Строки ===========================================================================================
		# Заметки:
			!функции шаблонизации не обязательно возвращать именно строку
			str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.
			str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.
			str.startsWith(s) – возвращает true, если строка str начинается со строки s.
			str.repeat(times) – повторяет строку str times раз.
		------------------------------------------------------------------------------------------------
		+ Строки-шаблоны они же `обратные кавычки`
		+ Вставляем выражения при помощи ${…}, так называемая "интерполяцией"
		+ Своя функция шаблонизация
		+ Создание символа из кода

	Объекты и прототипы ==============================================================================
		# Заметки:
			Object.setPrototypeOf(obj, newProto)  – метод для установки прототипа.
			Функция Object.assign – копирует свойства из всех аргументов в первый объект.
			Функция Object.is(value1, value2) - проверяет два значения на равенство. В отличие от === считает +0 и -0 разными числами. А также считает, что NaN равно самому себе.
			метод объекта get prop()
			метод объекта set prop()
			ключевое слово super, используется только в методах обекта, позволяет получить свойства его портотипа
		------------------------------------------------------------------------------------------------
		+ Короткое свойство
		+ Вычисляемые свойства с помощью []
		+ Object.assign или копирование свойств обекта в target
		+ Object.is(value1, value2) проверка равенства значений вместо ===
		+ Методы объекта
		+ Пример 1. Можно задать и метод с вычисляемым названием

	Классы ===========================================================================================
		# Заметки:
			!Class Expression. Наиболее очевидная область применения этой возможности (назначении имени классу) 
				создание вспомогательного класса прямо при вызове функции.
			!предполагается, что в прототипе должны быть только методы. Если свойство-значение, всё же, 
				необходимо, то можно создать геттер, который будет нужное значение возвращать.
			!Статические свойства - как правило, они используются для операций, не требующих наличия объекта. 
				Также статическими удобно делать константы.
			!в наследовании классов при вызове конструктора в наследнике через super, this определяет именно super.
			Синтакс классов выглядит так:
				class Название [extends Родитель]  {
				  constructor
				  методы
				}

			Синтакс классы-наследования:
				class Child extends Parent {
				  ...
				}
		------------------------------------------------------------------------------------------------
		+ Пример 1
		+ Class Expression
		+ Статические свойства
		+ Наследования

	Символы ==========================================================================================
		# Заметки:
			!Symbol.keyFor возвращает undefined, если символ не глобальный
			! В спецификации для краткости символы принято обозначать как „@@имя“, например @@iterator, 
				но доступны они как свойства Symbol.
			!Особенность символов в том, что если в объект записать свойство-символ, то оно не участвует в итерации
				Синтакс: let sym = Symbol();
				Symbol.for(name)
				Symbol.keyFor(sym)
		------------------------------------------------------------------------------------------------
		+ Пример 1.
		+ Пример 2. Символу можно задать имя
		+ Пример 3. Два одинаковых имени символа не равны друг другу
		+ Пример 4. Глобальные символы с помощью Symbol.for(name) для записи в реестр
		+ Пример 5. Обратный вызов глобального символа
		+ Пример 6. Особенности Symbol.for(name), т.е. символ должен быть глобальным
		+ Использование симолов, символ в качестви имени для свойства объекта
		+ Символы не участвую в итерации (переборе свойств for..in).
		+ Отсутствие конфликта нового системного свойства

	Итераторы ========================================================================================
		# Заметки:
			!Итератор – объект, предназначенный для перебора другого объекта.
			!Рекомендуется, свой итератор отделять от других функций.
		------------------------------------------------------------------------------------------------
		+ Пример итерации
		+ Пример итеретируемая строка
		+ Свой итератор
		+ Встроенные итераторы

	Set, Map, WeakSet и WeakMap ======================================================================
		# Заметки:
			!WeakMap и WeakSet нужны для тех ситуаций, когда основное место для хранения и использования 
				объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» 
				данные, существующие лишь пока жив объект. Если поместить такие данные в WeakMap, а объект сделать 
				ключом, то они будут автоматически удалены из памяти, когда удалится элемент.
			Map – коллекция записей вида ключ: значение, лучше Object тем, что перебирает всегда в порядке вставки и допускает любые ключи.
				Свойство проверки записей:
					map.size хранит общее количество записей в map.
				Методы для удаления записей:
					map.delete(key) удаляет запись с ключом key, возвращает true, если такая запись была, иначе false.
					map.clear() – удаляет все записи, очищает map.
				Для проверки существования ключа:
					map.has(key) – возвращает true, если ключ есть, иначе false.
				Для итерации по map используется один из трёх методов:
					map.keys() – возвращает итерируемый объект для ключей,
					map.values() – возвращает итерируемый объект для значений,
					map.entries() – возвращает итерируемый объект для записей [ключ, значение], он используется по умолчанию в for..of.
			Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.
				Основные методы:
					set.add(item) – добавляет в коллекцию item, возвращает set (чейнится).
					set.delete(item) – удаляет item из коллекции, возвращает true, если он там был, иначе false.
					set.has(item) – возвращает true, если item есть в коллекции, иначе false.
					set.clear() – очищает set.
					Перебор Set осуществляется через forEach или for..of аналогично Map
			WeakMap и WeakSet - особый вид Set не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map.
				Нет свойства size.
				Нельзя перебрать элементы итератором или forEach.
				Нет метода clear()
		------------------------------------------------------------------------------------------------
		+ Map -> Пример 1. Произвольные значения ключей-значений
		+ Map -> Пример 2. Метод set можно чейнить
		+ Map -> Пример 3. В качестве ключей map можно использовать и объекты
		+ Set -> Пример 1. Сохранение уникальных значений.
		+ Set -> Пример 2.
		+ WeakMap и WeakSet

	Промисы ==========================================================================================
		# Заметки:
			Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), 
				затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
			Промисификация – это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис.
			Чейнинг (chaining) - то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно используются промисы.

			Синтаксис создания Promise:
				var promise = new Promise(function(resolve, reject) {
				  // Эта функция будет вызвана автоматически

				  // В ней можно делать любые асинхронные операции,
				  // А когда они завершатся — нужно вызвать одно из:
				  // resolve(результат) при успешном выполнении
				  // reject(ошибка) при ошибке
				})

			!При возникновении ошибки – она отправляется в ближайший обработчик onRejected.
			!При чейнинге промисов главное не забыть обработать ошибки в конце. Если последнего catch не будет, 
				а цепочка завершится с ошибкой, то ошибка не будет нигде показана, она останется в промисе.
		# Параллельное выполнение промисов -> Заметки
			!!!Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат 
				уже есть.
			!Метод Promise.reject используется очень редко, гораздо реже чем resolve, потому что ошибка 
				возникает обычно не в начале цепочки, а в процессе её выполнения.

			Promise.all(iterable) - получает массив/объект промисов и возвращает промис, ждёт пока все 
				промисы завершатся, и переходит в состояние выполенно с массивом их результатов.
			Promise.race(iterable) - получает итерируемый массив/объект с промисами, которые нужно 
				выполнить, и возвращает новый промис. результатом будет только первый успешно выполнившийся 
				промис из списка. Остальные игнорируются.
			Promise.resolve(value) - создаёт успешно выполнившийся промис с результатом value.
			Promise.reject(error) - аналогично Promise.resolve(value) создаёт уже выполнившийся промис, 
				но не с успешным результатом, а с ошибкой error.
		------------------------------------------------------------------------------------------------
		+ Синтаксис создания Promise
		+ Универсальный метод для навешивания обработчиков
		+ С его помощью можно назначить как оба обработчика сразу, так и только один
		+ Синхронный throw – то же самое, что reject
		+ Пример 1.
		+ Пример 2. Выводит ошибку.
		+ Пример 3. !Promise после reject/resolve – неизменны
		+ Промисификация
		+ chaining - Цепочки промисов, без отлова ошибок
		+ Чейнинг промисов, с пробросом ошибки
		+ Параллельное выполнение промисов -> Promise.all(iterable)
		+ Параллельное выполнение промисов -> Promise.race(iterable)
		+ Параллельное выполнение промисов -> Promise.resolve(value)
		+ Параллельное выполнение промисов -> Promise.reject(error)
		+ z. Промисифицировать setTimeout
		+ z. Загрузить массив последовательно
		+ Пример из коментов, с аватаркой чисто на промисах

	Генераторы =======================================================================================
		# Заметки:
			Генераторы – function* (функция со звёздочкой) новый вид функций в современном JS. 
				Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать 
				промежуточный результат и далее возобновлять его позже, в произвольный момент времени.
			Композиция генераторов - включение одного генератора в другой.

			!Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
				Общий принцип такой:
					1) Генератор yield'ит не просто значения, а промисы.
					2) Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, 
						последовательными вызовами next получает из него промисы – один за другим, и, когда очередной 
						промис выполнится, возвращает его результат в генератор следующим next.
					3) Последнее значение генератора (done:true) execute уже обрабатывает как окончательный 
						результат – например, возвращает через промис куда-то ещё, во внешний код или просто
						использует, как в примере ниже.

			!!!При работе с библиотекой со обязательно нужен перехватчик ошибок catch.

			!!!одно из главных удобств использования генераторов. Несмотря на то, что 
				операции fetch – асинхронные, мы можем использовать обычный try..catch для обработки ошибок в них.
		------------------------------------------------------------------------------------------------
		+ Пример 1. Генератора.
		+ Перебор генератора.
		+ Композиция генераторов. 
		+ Использование возварённые значения для генератора
		+ Перехват ошибок в генераторах. generator.throw
		+ Перехват ошибок в генераторах. generator.throw -> Пример 1. Перехват в генераторе
		+ Перехват ошибок в генераторах. generator.throw -> Пример 2. Перехват снаружи
		+ Генератор+промис
		+ Генераторы+промисы+со(это библиотека)
		+ Перехват ошибок в со
		+ со+композиция_генераторов
		+ Сложный пример с загрузкой аватарки с гитхаба если никак то аватарка по умолч.

	Модули ===========================================================================================
		# Заметки:
			Модулем считается файл с кодом. В этом файле ключевым словом export помечаются переменные и функции,
				которые могут быть использованы снаружи. Другие модули могут подключать их через вызов import.

			!как правило, код стараются организовать так, чтобы каждый модуль делал одну вещь. Иначе говоря, 
				«один файл – одна сущность, которую он описывает». Например, файл user.js содержит class User, 
				файл login.js – функцию login() для авторизации, и т.п.
			!Для экспорта обязательно нужно имя.
		------------------------------------------------------------------------------------------------
		+ export
		+ export -> экспорт переменной прямо перед объявлением
		+ export -> экспорт переменной отдельно от объявления
		+ export -> экспорт для двух переменных
		+ export -> При помощи ключевого слова as указываем имя с которым переменная будет доступна
		+ export -> Экспорт функций и классов
		+ export -> export default, экспорт по умолчанию
		+ import
		+ import -> синтакс
		+ import -> Пример импорта
		+ import -> Импорт всех значений в виде объекта

	Proxy ============================================================================================
		# Заметки:
			Прокси (proxy) – особый объект, смысл которого – перехватывать обращения к другому объекту и, при 
				необходимости, модифицировать их.

			Полный список здесь: 
				https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler
		------------------------------------------------------------------------------------------------
		+ синтакс
		+ Пример прокси
		+ Пример прокси, обращение к не существущему свойству
		+ has - Ловушка has срабатывает в операторе in, когда проверяется наличие свойства.
		+ deleteProperty - Срабатывает при операции delete
		+ enumerate - Ловушка enumerate перехватывает операции for..in и for..of по объекту.
		+ apply - работа с функциями
		+ construct - перехватывает вызовы при помощи new.

<!-- Переменная let -->
	<script>
	'use strict';
	/*
	let
		1) Область видимости переменной let – блок {...}.
		2) Переменная let видна только после объявления.
		3) При использовании в цикле, для каждой итерации создаётся своя переменная.
	*/	
	
	// 1-2) ------------------------------------------------------------------------------------------
		console.log(apples); // ex.html:13 Uncaught ReferenceError: apples is not defined

		let apples = 5; // объявили переменную

		if (true) {
		  let apples = 10;

		  console.log(apples); // 10 (внутри блока)
		}

		console.log(apples); // 5 (снаружи блока значение не изменилось)
	
	// 3) --------------------------------------------------------------------------------------------
		//объявление через let
			function makeArmy() {

			  let shooters = [];

			  for (let i = 0; i < 10; i++) {
			    shooters.push(function() {
			      console.dir( i ); // выводит свой номер
			    });
			  }

			  return shooters;
			}

			var army = makeArmy();

			army[0](); // 0
			army[5](); // 5

		//и объявление через var
			function makeArmy() {

			  var shooters = [];

			  for (var i = 0; i < 10; i++) {
			    shooters.push(function() {
			      console.dir( i ); // выводит свой номер
			    });
			  }

			  return shooters;
			}

			var army = makeArmy();

			army[0](); // 0
			army[5](); // 5

	</script>

<!-- Деструктуризация -->
	<script>
	'use strict';

	//Отбрасывания элементов -------------------------------------------------------------------------
		// первый и второй элементы не нужны
		let [, , title] = "Юлий Цезарь Император Рима".split(" ");
		alert(title); // Император

	//Оператор spread он же ... позволяет получить остаток массива -----------------------------------
		let [firstName, lastName, ...other] = "Юлий Цезарь Император Рима".split(" ");
		alert(firstName); // Юлий
		alert(lastName);  // Цезарь
		alert(other);      // Император,Рима (массив из 2х элементов)

	//Значения по умолчанию в массиве через let через = ----------------------------------------------

		//примерчик 1. значение по умолчанию примитив.
			let [firstName="Гость", lastName="Анонимный"] = [];
			alert(firstName); // Гость
			alert(lastName);  // Анонимный

		//примерчик 2. значение по умолчанию некоторая функция
			function defaultLastName() {
			  return Date.now() + '-visitor';
			}
			// lastName получит значение, соответствующее текущей дате:
			let [firstName, lastName=defaultLastName()] = ["Вася"];
			alert(firstName); // Вася
			alert(lastName);  // 1436...-visitor

	//Деструктуризации массива -----------------------------------------------------------------------
		let [firstName, lastName] = ["Илья", "Кантор"];
		alert(firstName); // Илья
		alert(lastName);  // Кантор

	//Деструктуризация объекта -----------------------------------------------------------------------
	
		//примерчик 1. Заранее объявленные переменные -----------------------
			// !Чтобы избежать интерпретации {a, b} нужно обернуть всё присваивание в скобки.
			let a, b;
			({a, b} = {a:5, b:6}); // внутри выражения это уже не блок

		//примерчик 2.-------------------------------------------------------
			let options = {
			  title: "Меню",
			  width: 100,
			  height: 200
			};
			let {title, width, height} = options;
			alert(title);  // Меню
			alert(width);  // 100
			alert(height); // 200

		//примерчик 3. переназночение именни переменной----------------------
			let options = {
			  title: "Меню",
			  width: 100,
			  height: 200
			};
			//через : обозначаем переменную
			let {width: w, height: h, title} = options;
			alert(title);  // Меню
			alert(w);      // 100
			alert(h);      // 200

		//примерчик 4. значения по умолчанию---------------------------------
			let options = {
			  title: "Меню"
			};
			//через равно указываем значение по умолчанию
			let {width=100, height=200, title} = options;
			alert(title);  // Меню
			alert(width);  // 100
			alert(height); // 200

	//Деструктуризация объекта со вложенными объектами и массивами. ----------------------------------
		let options = {
		  size: {
		    width: 100,
		    height: 200
		  },
		  items: ["Пончик", "Пирожное"]
		}

		let { title="Меню", size: {width, height}, items: [item1, item2] } = options;

		// Меню 100 200 Пончик Пирожное
		alert(title);  // Меню
		alert(width);  // 100
		alert(height); // 200
		alert(item1);  // Пончик
		alert(item2);  // Пирожное

	</script>

<!-- Функции -->
	<script>
	'use strict';

	
	</script>

<!-- Строки -->
	<script>
	
	</script>

<!-- Объекты и прототипы -->
	<script>
	'use strict';



	</script>

<!-- Классы -->
	<script>
	'use strict';

	</script>

<!-- Символы -->
	<script>
	'use strict';

	
	</script>

<!-- Итераторы -->
	<script>
	'use strict';

	

	</script>

<!-- Set, Map, WeakSet и WeakMap -->


	<script>
	'use strict';
	

	</script>



<!-- Генераторы -->
	<script>
	'use strict';




	</script>

<!-- Модули -->

	<script>
	

	</script>

<!-- Proxy -->
	<script>

	
	
	</script>
</body>
</html>


