

<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Проверка JS</title>
</head>
<body>
	<div id="parent"></div>	

<!-- z1. Простой вывод сообщение через функцию alert. [alert()] 
	<script>
		alert("text");
	</script>
-->

<!-- Глобальный метод, eval. ЛУЧШЕ ЕГО НЕ ПРИМЕНЯТЬ! хорошая альтернатива это new function!-->
	<script>

	//Пример 1. Выполнение простого кода. ------------------------------------------------------------
		var a = 1;
		(function() {
		  var a = 2;
		  eval(' alert(a) '); // 2
		})()

	//Пример 2. возвращает последнее вычисленное выражение.-------------------------------------------
		alert( eval('1+1') ); // 2

	//Пример 3. Изменение переменной внутри ----------------------------------------------------------
		var x = 5;
		eval(" alert( x ); x = 10"); // 5, доступ к старому значению
		alert( x ); // 10, значение изменено внутри eval

	//Пример 4. Область видимости, с "use strict" объявленные внутри функц и перем не видны снаружи --
		"use strict";
		eval("var a = 5; function f() { }");
		alert( a ); // ошибка, переменная не определена
		// функция f тоже не видна снаружи
	 
	//Запуск скрипта в глобальной области ----------------------------------------------------кс[eval]
		/* Один из случаев где может пригодится Eval.
		допустим мы загрузили с сервера или вручную сгенерировали скрипт, который нужно выполнить.
		Желательно, в глобальной области, вне любых функций, чтобы он уж точно к локальным переменным 
		отношения не имел.
		*/
		//кросс-браузерный, без доступа к переменным.
		function globalEval(code) { // объединим два способа в одну функцию
		  window.execScript ? execScript(code) : window.eval(code);
		}

		var a = 1;

		(function() {

		  var a = 2;

		  globalEval(' alert(a) '); // 1, во всех браузерах

		})();

	//Альтернатива "eval" это "new function"	--------------------------------------------------------
		var a = 2,
		  b = 3;

		// вместо обращения к a,b через eval
		// будем принимать их как аргументы динамически созданной функции
		var mul = new Function('a, b', ' return a * b;');

		alert( mul(a, b) ); // 6

	//Работа с eval и JSON форматом. может встречатся в старом коде.
		var str = '{ \
	    "name": "Вася", \
	    "age": 25 \
		}';
		//если eval получает выражение в скобках ( ... ), то интерпретатор точно знает, что это не блок
		//кода, а объект
		var user = eval('( {  "name": "Вася",  "age": 25  } )');
		alert( user.age ); // 25

	</script>

<!-- z2. Подключение внешнего скрипта. [async,defer]
	после загрузки этого скрипта будет дальше загружатся остальная часть страницы
	<script src="z2.js"></script>
	скрипт загружется сразу как только полностью себя догрузит, может раньше остальных 
	<script async src="z1-2.js"></script>
	скрипт может загрузится раньше страницы, но сохранит последовательность с другими js
	<script defer src="z1-3.js"></script>
-->

<!-- z3. Работа с переменными
	<script>
		var admin; 					//простая переменная
		var NAME = "Василий"; 	//константа, как правило записывается капсом
		admin = name;
		alert(admin);
	</script>
-->

<!-- Вызов объекта 
	<script>//объявление объекта
		//var user = { name: "Вася" }; 
	</script>
-->

<!-- Побитовые операторы
	<script>
		var n1 = 2; 
		n1 += 5; // сокращённые выражения. теперь n=7 (работает как n = n + 5)
		
		var n2 = 123 ^ 0; // 123
		var n3 = 0 ^ 123; // 123
		var n4 = ~~123; // 123 - округление числа
		var n5 = 5 % 2; // 7 - остаток

		//isInteger(num), которая возвращает true, если num – целое число, иначе false.
		function isInteger(num) {
			return (num ^ 0) === num
		}
		var f1 = isInteger(1); // true
		var f2 = isInteger(1.5); // false
		var f3 = isInteger(-0.5); // false

		//при перемене мест – всегда ли результат остаётся тем же? Ответ да.
		var a=0 ,b=0;
		var z1 = (a ^ b == b ^ a);
		var z2 = (a & b == b & a);
		var z3 = (a | b == b | a);
			
		// в двоичном виде 1000000000000000000000000000000 (31 цифры)
		var x1 = Math.pow(2,30); // 1073741824
		var x2 = Math.pow((2,30)^0); // 1073741824, всё ок, длины хватает

		// в двоичном виде 100000000000000000000000000000000 (33 цифры)
		var x3 = Math.pow(2,32); // 4294967296
		var x4 = Math.pow((2,32)^0); // 0, отброшены старшие цифры, остались нули*/

		document.getElementById('parent').innerHTML = 
		'n1 (123 ^ 0) = ' + n1 + "<br>" +
		'n2 (123 ^ 0) = ' + n2 + "<br>" +
		'n3 (0 ^ 123) = ' + n3 + "<br>" +
		'n4 (~~123) = ' + n4 + "<br>" +
		'n5 (5 % 2) = ' + n1 + "<br>" +
		
		'f1 = ' + f1 + "<br>" +	
		'f2 = ' + f2 + "<br>" +	
		'f3 = ' + f3 + "<br>" +

		'z1 = ' + z1 + "<br>" +	
		'z2 = ' + z2 + "<br>" +	
		'z3 = ' + z3 + "<br>" +

		'x1 (Math.pow(2,30)) = ' + x1 + "<br>" +	
		'x2 (Math.pow((2,30)^0)) = ' + x2 + "<br>" +	
		'x3 (Math.pow(2,32)) = ' + x3 + "<br>" +	
		'x4 (Math.pow((2,32)^0)) = ' + x4;

	</script>
-->

<!-- Модальные окна: alert,prompt,confirm
	<script>
		var test = prompt("Тест", ''); // так лучше
		alert('Вы ввели ' + test);
		var isAdmin = confirm("Вы - администратор?");
		alert( isAdmin );
	</script>
-->

<!-- z4 Тернарный оператор, не рекомендуется. заменять его if(ом)
	<script>
		//Пример 1.1. через "if", тоже что и ниже
		if (a + b < 4) {
	  	result = 'Мало';
		} else {
		  result = 'Много';
		}
		//Пример 1.2. через "?", тоже что и выше
		result = (a + b < 4) ? 'Мало' : 'Много';

		//Пример 2.1
		var message;
		if (login == 'Вася') {
		  message = 'Привет';
		} else if (login == 'Директор') {
		  message = 'Здравствуйте';
		} else if (login == '') {
		  message = 'Нет логина';
		} else {
		  message = '';
		}
		//Пример 2.2
		var massage = (login == 'Вася') ? 'Привет' :
		(login == 'Директор') ? 'Здравствуйте' :
		(login == '') ? 'Нет логина' : 
		'';
		</script>
-->

<!-- Преоброзование типов 
	<script>
		//Преоброзование к строке
		alert( String(null) === "null" ); // true
		alert( true + "test" ); // "truetest"

		//Преоброзование к числу
		var a = +"123"; // 123
		var a = Number("123"); // 123, тот же эффект
		alert( true + "test" ); // "truetest" Сравнение разных типов – значит численное преобразование
		
		//Логическое преоброзование, см таблицу
		alert( !!"0" ); // true
		alert( !!" " ); // любые непустые строки, даже из пробелов - true!
	</script>
-->

<!-- ЦЫКЛЫ 
	<script>
		//while
		var i = 0;
		while (i < 3) {
		  alert( i );
		  i++;
		}

		//бесконечный цикл с помощью while
		while (true) {
		  // ...
		}

		//цикл do while
		var i = 0;
		do {
		  alert( i );
		  i++;
		} while (i < 3);

		//цикл for
		var i;
		for (i = 0; i < 3; i++) {
		  alert( i );
		}

		//директива break прерывание цикла
		var sum = 0;
		while (true) {
		  var value = +prompt("Введите число", '');
		  if (!value) break; // (*)
		  sum += value;
		}
		alert( 'Сумма: ' + sum );

		//директива continue, прекрощение текущего цикла
		for (var i = 0; i < 10; i++) {
		  if (i % 2 == 0) continue;
		  alert(i);
		}

		//директива break с меткой
		outer: for (var i = 0; i < 3; i++) {
		  for (var j = 0; j < 3; j++) {
		    var input = prompt('Значение в координатах '+i+','+j, '');
		    // если отмена ввода или пустая строка -
		    // завершить оба цикла
		    if (!input) break outer; // (*)
		  }
		}
		alert('Готово!');
	</script>
-->

<!-- z5. по циклам 
	<script>
		//При помощи цикла for выведите чётные числа от 2 до 10.
		// for (var i = 2; i<=10; i++) {
		// 	alert(i);
		// }

		//Перепишите код, заменив цикл for на while
		// for (var i = 0; i < 3; i++) {
		//   alert( "номер " + i + "!" );
		// }
		//решение
		// var i=0;
		// while (i<3) {
		// 	alert("номер " + i + "!");
		// 	i++;
		// }

		//повторяющийся цикл пока ввод не верен
		// var num;
		// do {
		// 	num = prompt("Введите число больше 100?", 0);
		// } while (num <=100 && num != null);

		// for (var i = 2; i <= 10; i++) {
		// 	if (i % 2 == 0) continue;
		// 	alert (i);
		// }
		// или
		// cont: for (var i = 2; i < 10; i++) { //счётчик от 2 до 10 с шагом +1
		// 	for (var j = 2; j < i; j++) {
		// 		if (i % j == 0) continue cont;
		// 	}
		// 	alert(i); //простое число
		// }
	</script>
-->

<!-- switch 
	<script>
		var a = 2 + 2;
		switch (a) {
		  case 3:
		    alert( 'Маловато' );
		    break;
		  case 4:
		    alert( 'В точку!' );
		    break;
		  case 5:
		    alert( 'Перебор' );
		    break;
		  default:
		    alert( 'Я таких значений не знаю' );
		}
	</script>
-->

<!-- z6. по wditch 
	<script>
		// //передалать этот вариант под if, решение ниже
		// switch (browser) {
		//   case 'IE':
		//     alert( 'О, да у вас IE!' );
		//     break;

		//   case 'Chrome':
		//   case 'Firefox':
		//   case 'Safari':
		//   case 'Opera':
		//     alert( 'Да, и эти браузеры мы поддерживаем' );
		//     break;

		//   default:
		//     alert( 'Мы надеемся, что и в вашем браузере все ок!' );
		// }
		// //тот же вариант но через if
		// browser = prompt ('Введите название браузера', '');
		// if (browser == 'IE') {
		// 	alert('О, да у вас IE');}
		
		// else if (browser == 'Chrome'||'Firefox'||'Safari'||'Opera') {
		// 	alert('Да, и эти браузеры поддерживаем');
		// }
		// else {
		// 	alert( 'Мы надеемся, что и в вашем браузере все ок!' );
		// }

		// var a = +prompt('a?', '');
		// switch (a) {
		// 	case 0 : alert(0); break;
		// 	case 1 : alert(1); break;
		// 	case 2 || 3 : alert('2,3'); break;
	 	// }
	</script>
-->

<!-- функции -->
	<script>
		//Работа с аргументами. Параметры копируются в локальные переменные функции.
		function showMessage(from, text) {
		  	from = '**' + from + '**'; // меняем локальную переменную from
		  	alert( from + ': ' + text );
		}
		var from = "User";
		showMessage(from, "Привет");
		alert( from ); // старое значение from без изменений, в функции была изменена копия
		// =========================================================================================
		//Работа с аргументами. вывод с необязательными аргументами
		function showMessage(from, text) {
		  	if (text === undefined) { //первый способ задать значение по умолчанию
		    	text = 'текст не передан';
		  	}
		  	//text = text || 'текст не передан'; //второй способ задать значение по умолчанию
		  	alert( from + ": " + text );
		}
		showMessage("User", "Привет!"); // User: Привет!
		showMessage("User"); // User: текст не передан
		// =========================================================================================
		//Функция checkAge через if
		function checkAge(age) {
		  	if (age > 18) {
		    	return true;
		  	} else {
		    	return confirm('Родители разрешили?');
		  	}
		}
		//Функция checkAge через ||
		function checkAge(age) {
			return (age > 18) || confirm('Родители разрешили?');
		}
		//Функция checkAge через ?
		function checkAge(age) {
			return (age > 18) ? true : confirm('Родители разрешили?') ;
		}
		// =========================================================================================		
		//Функция возращающая меньшее из двух чисел
		function min(a, b) {
		  	if (a < b) {
		   	 	return a;
		  	} else {
		    	return b;
		  	}
		}
		//Функция возращающая меньшее из двух чисел.Вариант решения с оператором '?'
		function min(a, b) {
		  	return a < b ? a : b;
		}
		// =========================================================================================
		Функция производящая математическое вычисление, пример: pow(3, 3) = 3 * 3 * 3 = 27
		function pow(x,n) {
			var result = x;
			for (var i = 1; i < n; i++) {
				result *=x; //result = result * x
			}
			return result;
		}
		var x = prompt ('Введите число', '');
		var n = prompt ('Введите n-число', '');
		if (n <= 1) {
			alert('Степень ' + n + 'не поддерживается, введите целую степень, больше 1');
		} else {
			alert( pow(x,n) );
 			}
		// =========================================================================================
		//Вывести код функции
		function sayHi() {
		  	alert( "Привет" );
		}
		alert( sayHi ); // выведет код функции
		// =========================================================================================
		// 1) Function Declaration
		function sum(a, b) {
		  	return a + b;
		}

		// 2) Function Expression
		var sum = function(a, b) {
		  	return a + b;
		}

		// 3) new Funciton
		var sum = new Function('a,b', ' return a+b; ');
		var result = sum(1, 2);
		alert( result ); // 3
		// =========================================================================================
		//Function Declaration – функция, объявленная в основном потоке кода.
		function sayHi() {   // (1)
		  	alert( "Привет" );
		}
		sayHi();

		//Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.
		var sayHi = function(person) {
  		alert( "Привет, " + person );
		};
		sayHi('Вася');
		// =========================================================================================
		//Функция ask, выводит окно, да или отмена, и в зависимости от этого по функции выводит окошко
		//пример анонимных функций
		function ask(question, yes, no) {
		  	if (confirm(question)) yes()
		  	else no();
		}
		ask(
		  	"Вы согласны?",
		  	function() { alert("Вы согласились."); },
		  	function() { alert("Вы отменили выполнение."); }
		);
		//Рекурсия
		function pow(x, n) {
		  	if (n != 1) { // пока n != 1, сводить вычисление pow(x,n) к pow(x,n-1)
		    	return x * pow(x, n - 1);
		  	} else {
		    	return x;
		  	}
		}
		alert( pow(2, 3) ); // 8	

	</script>

<!-- z7. по функциям 
	<script>
		//Вычислить сумму чисел до данного
		//через цикл
		function sumTo(n) {
			var sum = 0;
			for (var i=1; i<=n; i++) {
				sum += i;
			}
			return sum;
		}
		alert ( sumTo(100));

		//через рекурсию
		function sumTo(n) {
			if (n == 1) return 1;
			return n + sumTo(n - 1);
		}
		alert ( sumTo(100));

		//через формулу
		function sumTo(n) {
			return n*(n+1)/2;
		}
		alert( sumTo(100));
		// =========================================================================================
		//Вычислить факториал
		function factorial (n) {
			return (n!=1) ? n * factorial (n - 1) : 1;
		}
		alert( factorial(5));//120
		// =========================================================================================
		Числа фибоначчи
		логика вычислений
		a = b, b = c;
		c = a + b;
		стало так (ещё число):
		      a  b  c
		1, 1, 2, 3, 5

		function fib(n) {
			var a = 1, b = 1;
			//Цикл здесь начинается с i=3, так как первое и второе числа Фибоначчи заранее записаны в переменные a=1, b=1.
			for (var i = 3; i <= n; i++) {
				var c = a + b;
				a = b;
				b = c;
			}
			return b;
		}
		alert(fib(3)); //2
		alert(fib(7)); //13
		alert(fib(77)); //5527939700884757
	</script>
-->

<!-- Отладка 
	<script>
		// результат будет виден в консоли
		for (var i = 0; i < 5; i++) {
		  console.log("значение", i);
		}
		// Создание точки останова или брейкпоинта
		function pow(x, n) {
		  	//code
		  	debugger; // <== отладчик остановится тут
		  	//code
		}
	</script>
-->

<!-- Тесты. более подробно в папке testInJS
	<script>
		describe("pow", function() {

		  it("возводит в n-ю степень", function() {
		    assert.equal(pow(2, 3), 8);
		  });

		});
	</script>
-->

<!-- Свойства и методы 
	<script>
	//свойство .length длина переменной
		var str = "Привет, мир!";
		alert( str.length ); // 12
	//метод toUpperCase() возвращает строку в верхнем регистре
		var hello = "Привет, мир!";
		alert( hello.toUpperCase() ); // "ПРИВЕТ, МИР!"
	//метод num.toFixed(n) округляет число num до n знаков после запятой
		var n = 12.345;
		alert( n.toFixed(2) ); // "12.35"
		alert( n.toFixed(0) ); // "12"
		alert( n.toFixed(5) ); // "12.34500"
		//можно и другим способом, так 12.. потому что круглое целое число приведёт к ошибке
		alert( 12..toFixed(1) ); // 12.0
	</script>
-->

<!-- Числа -->
	<script>
		
		
	</script>


<!-- z. Числа -->
	<script>
	

	</script>


<!-- Строки -->
	<script>
	
	</script>


<!-- Объекты как ассоциативные массивы -->
	<script>

	</script>



<!-- Аргументы -->
	<script>
	
	</script>


<!-- Дата и время -->
	<script>


	</script>

<!-- Бенчмаркинг 
	<script>
	/*
	Для правильного бенчмаркинга функция запускается много раз, чтобы сам тест занял существенное время. Это сведет влияние помех к минимуму. Сложную функцию можно запускать 100 раз, простую – 1000 раз	
	*/	
	//упращённый
		var arr = [];
		for (var i = 0; i < 1000; i++) arr[i] = 0;

		function walkIn(arr) {
		  for (var key in arr) arr[key]++;
		}

		function walkLength(arr) {
		  for (var i = 0; i < arr.length; i++) arr[i]++;
		}

		function bench(f) {
		  var date = new Date();
		  for (var i = 0; i < 10000; i++) f(arr);
		  return new Date() - date;
		}

		alert( 'Время walkIn: ' + bench(walkIn) + 'мс' );
		alert( 'Время walkLength: ' + bench(walkLength) + 'мс' );
	//более надёжный, чередует
		var arr = [];
		for (var i = 0; i < 1000; i++) arr[i] = 0;

		function walkIn(arr) {
		  for (var key in arr) arr[key]++;
		}

		function walkLength(arr) {
		  for (var i = 0; i < arr.length; i++) arr[i]++;
		}

		function bench(f) {
		  var date = new Date();
		  for (var i = 0; i < 1000; i++) f(arr);
		  return new Date() - date;
		}

		// bench для каждого теста запустим много раз, чередуя
		var timeIn = 0,
		  timeLength = 0;
		for (var i = 0; i < 100; i++) {
		  timeIn += bench(walkIn);
		  timeLength += bench(walkLength);
		}

		alert( 'Время walkIn: ' + timeIn + 'мс' );
		alert( 'Время walkLength: ' + timeLength + 'мс' );

	// !не забываем и про функцию performance.now() читтайте справочник, лучше пользоватся им
	
	//console.time(метка) и console.timeEnd(метка)
		var arr = [];
		for (var i = 0; i < 1000; i++) arr[i] = 0;

		function walkIn(arr) {
		  for (var key in arr) arr[key]++;
		}

		function walkLength(arr) {
		  for (var i = 0; i < arr.length; i++) arr[i]++;
		}

		function bench(f) {
		  for (var i = 0; i < 10000; i++) f(arr);
		}

		console.time("All Benchmarks");

		console.time("walkIn");
		bench(walkIn);
		console.timeEnd("walkIn");

		console.time("walkLength");
		bench(walkLength);
		console.timeEnd("walkLength");

		console.timeEnd("All Benchmarks");
	</script>
-->	

<!-- Замыкания схема -->
	<script>
	window { //window = { f: function }
	  functon f { //functon f { [[Scope]], LexicalEnvironment, }
	    //скрытое свойство, хранит ссылки на внутренний текущий и внешний объект. "Если переменная не найдена внутри, она будет искатся снаружи"
	    [[Scope]] 
	    //скрытый объект хранит содержимое функции. "переменные"
	    LexicalEnvironment = { variable_1: undefined, variable_2: undefined } 
	  }
	}

	</script>

<!-- Замыкания -->
	<script>
	//счётчик модифицированный
		function makeCounter() {
		  var currentCount = 1;

		  // возвращаемся к функции
		  function counter() {
		      return currentCount++;
		    }

		  // ...и добавляем ей методы!
		  counter.set = function(value) {
		    currentCount = value;
		  };

		  counter.reset = function() {
		    currentCount = 1;
		  };

		  return counter;
		}

		var counter = makeCounter();

		alert( counter() ); // 1
		alert( counter() ); // 2

		counter.set(5);
		alert( counter() ); // 5

	//z. Сумма через замыкания
		function sum (a) {

		  return function(b) {
		    return a + b;
		  }
		}
		console.log( sum(1)(2) );

	//z. Функция - строковый буфер + доп-функция
		function makeBuffer() {
		  var text = '';

		  buffer.clear = function () {
		  	text = '';
		  }

		  function buffer(piece) {
		    if (arguments.length == 0) {
		 		  return text;
		  	}
		  	text +=piece;
		  }

		  return buffer;
		}

		var buffer = makeBuffer();

		buffer("Тест");
		buffer(" тебя не съест ");
		console.log( buffer() ); // Тест тебя не съест

		buffer.clear();
		console.log( buffer() ); // ""
	//z. Сортировка массива объектов
		var users = [{
		  name: "Вася",
		  surname: 'Иванов',
		  age: 20
		}, {
		  name: "Петя",
		  surname: 'Чапаев',
		  age: 25
		}, {
		  name: "Маша",
		  surname: 'Медведева',
		  age: 18
		}];


		function byField (field) {
		  return function(a, b) {
		    return a[field] > b[field] ? 1 : -1;
		  };
		}

		users.sort(byField('name')); //массив_объектов.сортировка.по_функции
		users.forEach(function(user) { //массив_объектов.перебор.по_функции
		  console.log( user.name );
		}); // Вася, Маша, Петя

		users.sort(byField('age'));
		users.forEach(function(user) {
		  console.log( user.name );
		}); // Маша, Вася, Петя

	//z. Список функций
		function makeArmy() {

		  var shooters = [];

		  for (var i = 0; i < 10; i++) {

		    var shooter = (function(x) {

		      return function() {
		        //alert( x );
		        console.log( x );
		      };

		    })(i);

		    shooters.push(shooter);
		  }

		  return shooters;
		}

		var army = makeArmy();

		army[0](); // 0
		army[1](); // 1


	</script>

<!-- Модули и библиотеки, экспорт значений -->
	<script>

	//Способ 1. выдержка из исходного файла.
		(function() {

		  // lodash - основная функция для библиотеки
		  function lodash(value) {
		    // ...
		  }

		  // вспомогательная переменная
		  var version = '2.4.1';
		  // ... другие вспомогательные переменные и функции

		  // код функции size, пока что доступен только внутри
		  function size(collection) {
		    return Object.keys(collection).length;
		  }

		  // присвоим в lodash size и другие функции, которые нужно вынести из модуля
		  lodash.size = size
		  // lodash.defaults = ...
		  // lodash.cloneDeep = ...

		  // "экспортировать" lodash наружу из модуля
		  window._ = lodash; // в оригинальном коде здесь сложнее, но смысл тот же

		}());

	//Способ 2. через return
	var lodash = (function() {

	  var version;
	  function assignDefaults() { ... }

	  return {
	    defaults: function() {  }
	  }

	})();
	
	</script>

<!-- this, call, apply, arguments, bind, [[class]] -->
	<script>
	// Значение this в зависимости от вызова -------------------------------------------------------
		// При вызове функции как метода:
			obj.func(...)    // this = obj
			obj["func"](...)

		// При обычном вызове:
			func(...) // this = window (ES3) /undefined (ES5)

		// В new:
			new func() // this = {} (новый объект)

		// Явное указание:
			func.apply(context, args) // this = context (явная передача)
			func.call(context, arg1, arg2, ...)

	//использование this ---------------------------------------------------------------------------
		var user = {
		  name: 'Василий',

		  sayHi: function() {
		    alert( this.name );
		  }
		};

		user.sayHi(); // sayHi в контексте user		

	//использование this ---------------------------------------------------------------------------
		function sayHi() {
		  alert( this.firstName ); //this пока не знает с каким обхектом будет работать
		}

	// использование this, два вызова --------------------------------------------------------------
		var user = { firstName: "Вася" };
		var admin = { firstName: "Админ" };

		function func() {
		  alert( this.firstName );
		}

		user.f = func;
		admin.g = func;

		// this равен объекту перед точкой:
		user.f(); // Вася
		admin.g(); // Админ
		admin['g'](); // Админ (не важно, доступ к объекту через точку или квадратные скобки)

	//z. Калькулятор через this --------------------------------------------------------------------
		var calculator = {

		  sum: function() {
		    return this.a + this.b;
		  },

		  mul: function() {
		    return this.a * this.b;
		  },

		  read: function () {
		    this.a = +prompt("a?", "0");
		    this.b = +prompt("b?", "0");
		  }

		}

		calculator.read();
		alert( calculator.sum() );
		alert( calculator.mul() );
		
	//z. Цепочка вызовов "чейнинг" через this. -----------------------------------------------------
		var ladder = {
		  step: 0,
		  up: function() { // вверх по лестнице
		    this.step++;
		    return this;
		  },
		  down: function() { // вниз по лестнице
		    this.step--;
		    return this;
		  },
		  showStep: function() { // вывести текущую ступеньку
		    alert( this.step );
		    return this;
		  }

		};

		ladder.up().up().down().up().down().showStep(); // 1

	// Метод call. Пример 1. -----------------------------------------------------------------------
		function showFullName() {
		  alert( this.firstName + " " + this.lastName );
		}

		var user = {
		  firstName: "Василий",
		  lastName: "Петров"
		};

		// функция вызовется с this=user
		showFullName.call(user) // "Василий Петров"

	// Метод call. Пример 2. -----------------------------------------------------------------------
		var user = {
		  firstName: "Василий",
		  surname: "Петров",
		  patronym: "Иванович"
		};

		function showFullName(firstPart, lastPart) {
		  alert( this[firstPart] + " " + this[lastPart] );
		}

		// f.call(контекст, аргумент1, аргумент2, ...)
		showFullName.call(user, 'firstName', 'surname') // "Василий Петров"
		showFullName.call(user, 'firstName', 'patronym') // "Василий Иванович"

	// Одалживание метода. кс:[объект, массив, this, call, arguments] -------------------------------
		// безобасный вызов метода Join через call
		function printArgs() {
		  var join = [].join; // скопируем ссылку на функцию в переменную
		  // вызовем join с this=arguments,
		  // этот вызов эквивалентен arguments.join(':') из примера выше
		  var argStr = join.call(arguments, ':');
		  alert( argStr ); // сработает и выведет 1:2:3
		}
		printArgs(1, 2, 3);
		//Мы вызвали метод без копирования. Чисто, безопасно.

	// Создание массива из аргументов. кс:[массив, call, аргумент] ---------------------------------
		function printArgs() {
		  // вызов arr.slice() скопирует все элементы из this в новый массив
		  var args = [].slice.call(arguments);
		  alert( args.join(', ') ); // args - полноценный массив из аргументов
		}
		printArgs('Привет', 'мой', 'мир'); // Привет, мой, мир

	// Получить максимальный элемент в массиве. кс:[массив, apply] ---------------------------------
		var arr = [];
		arr.push(1);
		arr.push(5);
		arr.push(2);
		// получить максимум из элементов arr
		alert( Math.max.apply(null, arr) ); //тут вместо this можно обойтись null

	//z. Сумма аргументов. кл:[call, аргумент, массив] ---------------------------------------------
		"use strict"
		function sumArgs() {
		  // запустим reduce из массива напрямую
		  return [].reduce.call(arguments, function(a, b) {
		    return a + b;
		  });
		}
		alert( sumArgs(1, 2, 3) ); // 6, аргументы переданы через запятую, без массива	

	//z. Применение функций к аргументам. кл:[apply, this, call, arguments, массив] ----------------
		"use strict"

		function applyAll(func) {
		  //применяем функцию "func" к массиву аргументов "apply" параметры которого (текущий "this", массив с скопированными аргументами "[].slice.call" параметры которого (аргументы начиная со второй позиции "arguments, 1"))
		    return func.apply(this, [].slice.call(arguments, 1));
		  }

		// Применить Math.max к аргументам 2, -2, 3
		alert( applyAll(Math.max, 2, -2, 3) ); // 3

		// Применить Math.min к аргументам 2, -2, 3
		alert( applyAll(Math.min, 2, -2, 3) ); // -2

		function sum() { // суммирует аргументы: sum(1,2,3) = 6
		  return [].reduce.call(arguments, function(a, b) {
		    return a + b;
		  });
		}

		function mul() { // перемножает аргументы: mul(2,3,4) = 24
		  return [].reduce.call(arguments, function(a, b) {
		    return a * b;
		  });
		}

		alert( applyAll(sum, 1, 2, 3) ); // -> sum(1, 2, 3) = 6
		alert( applyAll(mul, 2, 3, 4) ); // -> mul(2, 3, 4) = 24

	// bind для привязки контекста -----------------------------------------------------------------
		// ручная, можно пользоватся и встроенной функцией
		function bind(func, context) {
		  return function() { // (*)
		    return func.apply(context, arguments);
		  };
		} // end bid

		function f() {
		  alert( this );
		}
		// bind(f, "Context") привязывает "Context" в качестве this для f.
		var g = bind(f, "Context");
		g(); // Context

	// bind для привязки контекста с несколькими аргументами ---------------------------------------
		// ручная, можно пользоватся и встроенной функцией
		function bind(func, context) {
		  return function() { // (*)
		    return func.apply(context, arguments);
		  };
		} // end bid

		var user = {
		  firstName: "Вася",
		  sayHi: function(who) { // здесь у sayHi есть один аргумент
		    alert( this.firstName + ": Привет, " + who );
		  }
		};

		var sayHi = bind(user.sayHi, user); //достаточно 1 раз, после чего запоминает

		// контекст Вася, а аргумент передаётся "как есть"
		sayHi("Петя"); // Вася: Привет, Петя
		sayHi("Маша"); // Вася: Привет, Маша

	// Встроенный bind. Пример 1. ------------------------------------------------------------------
		// Синтакс встроенного func.bind(context[, arg1, arg2...])
		function f(a, b) {
		  alert( this );
		  alert( a + b );
		}

		// вместо
		// var g = bind(f, "Context");
		var g = f.bind("Context");
		g(1, 2); // Context, затем 3

	// Встроенный bind. Пример 2. ------------------------------------------------------------------
		function f() {
		  alert(this.name);
		}

		f = f.bind( {name: "Вася"} ); // объект служит контекстом

		f();

	// Встроенный bind. Пример 3. ------------------------------------------------------------------
		var user = {
		  firstName: "Вася",
		  sayHi: function() {
		    alert( this.firstName );
		  }
		};

		// setTimeout( bind(user.sayHi, user), 1000 ); // как было бы через ручной что выше
		setTimeout(user.sayHi.bind(user), 1000); // аналог через встроенный метод

	// Привязать всё: bindAll. Привязываем все методы к контексту ----------------------------------
		for (var prop in user) {
		  if (typeof user[prop] == 'function') {
		    user[prop] = user[prop].bind(user);
		  }
		}

	// Карринг. Привязка через bind часто используемого аргумента к функции ------------------------
		function mul(a, b) {
		  return a * b;
		};

		// double умножает только на два
		var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

		alert( double(3) ); // = mul(2, 3) = 6
		alert( double(4) ); // = mul(2, 4) = 8
		alert( double(5) ); // = mul(2, 5) = 10

		// или вот

		var triple = mul.bind(null, 3); // контекст фиксируем null, он не используется

		alert( triple(3) ); // = mul(3, 3) = 9
		alert( triple(4) ); // = mul(3, 4) = 12
		alert( triple(5) ); // = mul(3, 5) = 15

	// Кросс-браузерная эмуляция bind --------------------------------------------------------------
		/*
		1. Вызов bind сохраняет дополнительные аргументы args (они идут со 2-го номера) в массив 
			 bindArgs.
		2. … и возвращает обертку wrapper.
		3. Эта обёртка делает из arguments массив args и затем, используя метод concat, прибавляет их 
			 к аргументам bindArgs (карринг).
		4. Затем передаёт вызов func с контекстом и общим массивом аргументов.
		*/

		function bind(func, context /*, args*/) {
		  var bindArgs = [].slice.call(arguments, 2); // (1)
		  function wrapper() {                        // (2)
		    var args = [].slice.call(arguments);
		    var unshiftArgs = bindArgs.concat(args);  // (3)
		    return func.apply(context, unshiftArgs);  // (4)
		  }
		  return wrapper;
		}

	/* Декораторы ================================================================================= */ 
	
	// Декоратор-таймер ----------------------------------------------------------------------------
		// шаблончик
		  function f(x) {} // любая функция

		  var timers = {}; // объект для таймеров

		  // отдекорировали
		  f = timingDecorator(f, "myFunc");

		  // запускаем
		  f(1);
		  f(2);
		  f(3); // функция работает как раньше, но время подсчитывается

		  alert( timers.myFunc ); // общее время выполнения всех вызовов f
	 
	// Пример по шаблону. Декоратор-таймер ---------------------------------------------------------
		var timers = {};

		// прибавит время выполнения f к таймеру timers[timer]
	  function timingDecorator(f, timer) {
	    return function() {
	      var start = performance.now();
	      console.log(start);
	      var result = f.apply(this, arguments); // (*)

	      if (!timers[timer]) timers[timer] = 0;
	      timers[timer] += performance.now() - start;

	      return result;
	    }
	  }

  	// функция может быть произвольной, например такой: --------------------------------------------
	  var fibonacci = function f(n) {
	    return (n > 2) ? f(n - 1) + f(n - 2) : 1;
	  }

	  // использование: завернём fibonacci в декоратор
	  fibonacci = timingDecorator(fibonacci, "fibo");

	  // неоднократные вызовы...
	  alert( fibonacci(10) ); // 55
	  alert( fibonacci(20) ); // 6765
	  // ...

	  // в любой момент можно получить общее количество времени на вызовы
	  alert( timers.fibo + 'мс' );

	// Декоратор типов -----------------------------------------------------------------------------
		// вспомогательная функция для проверки на число
		function checkNumber(value) {
		  return typeof value == 'number';
		}

		// декоратор, проверяющий типы для f
		// второй аргумент checks - массив с функциями для проверки
		function typeCheck(f, checks) {
		  return function() {
		    for (var i = 0; i < arguments.length; i++) {
		      if (!checks[i](arguments[i])) {
		        alert( "Некорректный тип аргумента номер " + i );
		        return;
		      }
		    }
		    return f.apply(this, arguments);
		  }
		}

		function sum(a, b) {
		  return a + b;
		}

		// обернём декоратор для проверки
		sum = typeCheck(sum, [checkNumber, checkNumber]); // оба аргумента - числа

		// пользуемся функцией как обычно
		alert( sum(1, 2) ); // 3, все хорошо

		// а вот так - будет ошибка
		sum(true, null); // некорректный аргумент номер 0
		sum(1, ["array", "in", "sum?!?"]); // некорректный аргумент номер 1

		// Конечно, этот декоратор можно ещё расширять, улучшать, дописывать проверки, но… Вы уже поняли принцип, не правда ли?
		// Один раз пишем декоратор и дальше просто применяем этот функционал везде, где нужно.

	// Декоратор проверки доступа ------------------------------------------------------------------
		function checkPermissionDecorator(f) {
		  return function() {
		    if (isAdmin()) {
		      return f.apply(this, arguments);
		    }
		    alert( 'Недостаточно прав' );
		  }
		}

		//Использование декоратора
		function save() { ... }
		save = checkPermissionDecorator(save);
		// Теперь вызов функции save() проверяет права
	
	// Логирование функции с 1 аргументом ----------------------------------------------------------
		"use strict";
		function work(a) {
		  /*...*/ // work - произвольная функция, один аргумент
		}

		function makeLogging(f, log) {

		  function wrapper(a) {
		      log.push(a);
		      return f.call(this, a);
		    }

		  return wrapper;
		}

		var log = [];
		work = makeLogging(work, log);

		work(1); // 1
		work(5); // 5

		for (var i = 0; i < log.length; i++) {
		  alert( 'Лог:' + log[i] ); // "Лог:1", затем "Лог:5"
		}
	
	// логирование функции с несколькими аргументами. ----------------------------------------------
		"use strict";
		function work(a, b) {
		  alert( a + b ); // work - произвольная функция
		}

		function makeLogging(f, log) {
		  function wrapper(a, b) {
		    log.push(a);
		    log.push(b);
		    return f.apply(this, arguments);
		  }
		  return wrapper;
		}

		function makeLogging(f, log) {

		  function wrapper() {
		      //создаём массив log из аргументов, путём добавления пушом
		      log.push([].slice.call(arguments));
		      return f.apply(this, arguments);
		    }

		  return wrapper;
		}

		var log = [];
		work = makeLogging(work, log);

		work(1, 2); // 3
		work(4, 5); // 9

		for (var i = 0; i < log.length; i++) {
		  var args = log[i]; // массив из аргументов i-го вызова
		  alert( 'Лог:' + args.join() ); // "Лог:1,2", "Лог:4,5"
		}

	// Кешеирующий декоратор -----------------------------------------------------------------------
		"use strict";
		function f(x) {
		  return Math.random()*x;
		}

		function makeCaching(f) {
		  var cache = {};

		  return function(x) {
		    if (!(x in cache)) {
		      cache[x] = f.call(this, x);
		    }
		    return cache[x];
		  };

		}

		f = makeCaching(f);

		var a = f(1);
		var b = f(1);
		alert( a == b ); // true (значение закешировано)

		b = f(2);
		alert( a == b ); // false, другой аргумент => другое значение
		/*
		Обратите внимание: проверка на наличие уже подсчитанного значения выглядит так: if (x in cache). 
		Менее универсально можно проверить так: if (cache[x]), это если мы точно знаем, что cache[x] 
		никогда не будет false, 0 и т.п.
		*/
	
	/* ============================================================================================ */
	
	// Секретное свойство [[class]] ------------------------------------------------------------------
		/* 
		Для получения [[Class]] нужна именно внутренняя реализация toString стандартного объекта 
		Object, другая не подойдёт. Заметим, что свойство [[Class]] есть и доступно для чтения указанным
		способом – у всех встроенных объектов. Но его нет у объектов, которые создают наши функции. 
		Точнее, оно есть, но равно всегда "Object".
		*/

		//метод стандартного обекта, так как у arr и date свои методы, и могут работать иначе.
		var toString = {}.toString;

		var arr = [1, 2];
		alert( toString.call(arr) ); // [object Array]

		var date = new Date;
		alert( toString.call(date) ); // [object Date]

		var user = { name: "Вася" };
		alert( toString.call(user) ); // [object Object] //не встроенная, только Object а не user
		
	// спец функция определяющая тип объекта ---------------------------------------------------------
		function getClass(obj) {
		  return {}.toString.call(obj).slice(8, -1);
		}
		alert( getClass(new Date) ); // Date
		alert( getClass([1, 2, 3]) ); // Array

	// Проверка на массив. Метод Array.isArray() -----------------------------------------------------
		alert( Array.isArray([1,2,3]) ); // true
		alert( Array.isArray("not array")); // false

	//z. Работа с разными типами данных в дате кс:[typeof, Array.isArray(), Date] --------------------
		"use strict";
    function formatDate(date) {
      if (typeof date == 'number') {
        // перевести секунды в миллисекунды и преобразовать к Date
        date = new Date(date * 1000);
      } else if (typeof date == 'string') {
        // строка в стандартном формате автоматически будет разобрана в дату
        date = new Date(date); 
      } else if (Array.isArray(date)) { 
        date = new Date(date[0], date[1], date[2]);
      }
      // преобразования для поддержки полиморфизма завершены, 
      // теперь мы работаем с датой (форматируем её)
    
      //либо подлиньше но будут проблемы с IE
      // return date.toLocaleString("ru", {day: '2-digit', month: '2-digit', year: '2-digit'});
    
      
      // можно и вручную, если лень добавлять в старый IE поддержку локализации
      var day = date.getDate();
      if (day < 10) day = '0' + day;
    
      var month = date.getMonth() + 1;
      if (month < 10) month = '0' + month;
    
      // взять 2 последние цифры года
      var year = date.getFullYear() % 100;
      if (year < 10) year = '0' + year;
    
      var formattedDate = day + '.' + month + '.' + year;
      
      return formattedDate;
    }

		alert( formatDate('2011-10-02') ); // 02.10.11
		alert( formatDate(1234567890) ); // 14.02.09
		alert( formatDate([2014, 0, 1]) ); // 01.01.14
		alert( formatDate(new Date(2014, 0, 1)) ); // 01.01.14

	</script>


<!-- Ввод и вывод, взаимодействие с пользователем -->
	<script>
	/* Её назначение – задать вопрос question и, если ответ совпадёт с answer, то запустить функцию 
	ok(), а иначе – функцию fail(). */
		function ask(question, answer, ok, fail) {
		  var result = prompt(question, '');
		  if (result.toLowerCase() == answer.toLowerCase()) ok();
		  else fail();
		}

		ask("Выпустить птичку?", "да", fly, die);

		function fly() {
		  alert( 'улетела :)' );
		}

		function die() {
		  alert( 'птичку жалко :(' );
		}

	//z. Взаимодействие с пользователем. Проверка пароля.
		"use strict";

		function ask(question, answer, ok, fail) {
		  var result = prompt(question, '');
		  if (result.toLowerCase() == answer.toLowerCase()) ok();
		  else fail();
		}

		var user = {
		  login: 'Василий',
		  password: '12345',

		  loginOk: function() {
		    alert( this.login + ' вошёл в сайт' );
		  },

		  loginFail: function() {
		    alert( this.login + ': ошибка входа' );
		  },

		  checkPassword: function() {
		    ask("Ваш пароль?", this.password, this.loginOk.bind(this), this.loginFail.bind(this));
		  }
		};

		user.checkPassword();

	//z. Взаимодействие с пользователем. Проверка пароля с использованием карринга
		//Этот вариант похож не предыдущий, только сначало проверяется условие на истиность после чего выполняется соответствующее действие.
		"use strict";

		function ask(question, answer, ok, fail) {
		  var result = prompt(question, '');
		  if (result.toLowerCase() == answer.toLowerCase()) ok();
		  else fail();
		}

		var user = {
		  login: 'Василий',
		  password: '12345',

		  loginDone: function(result) {
		    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );
		  },

		  checkPassword: function() {
		    ask("Ваш пароль?", this.password, this.loginDone.bind(this, true), this.loginDone.bind(this, false));
		  }
		};

		user.checkPassword();

	</script>
	
<!-- Преоброзования объектов -->
	<script>
	//z. Сумма произвольного количества скобок
	function sum(a) {

	  var currentSum = a;

	  function f(b) {
	    currentSum += b;
	    return f;
	  }

	  f.toString = function() {
	    return currentSum;
	  };

	  return f;
	}

	alert( sum(1)(2) ); // 3
	alert( sum(5)(-1)(2) ); // 6
	alert( sum(6)(-1)(-2)(-3) ); // 0
	alert( sum(0)(1)(2)(3)(4)(5) ); // 15

	</script>


<!-- z. Объекты + массивы + this + new + добавление метода-->
	<script>
	//создаём функцию конструктор
	function Calculator() {

	  //они имеет 2 метода, вычитание и сложение
	  var methods = {
	    "-": function(a, b) {
	      return a - b;
	    },
	    "+": function(a, b) {
	      return a + b;
	    }
	  };

	  //создаём свойство calculate для преоброзование к строке
	  this.calculate = function(str) {
	    //разбиваем пробелом на массивы
	    var split = str.split(' '), 
	      a = +split[0],
	      op = split[1],
	      b = +split[2]

	    //если замечена ошибка возращаем NaN
	    if (!methods[op] || isNaN(a) || isNaN(b)) {
	      return NaN;
	    }
	    //в штатном режиме производим операцию в возращении
	    return methods[op](+a, +b); //метод операция (преобразованный параметр а, b)
	  }

	  this.addMethod = function(name, func) {
	    methods[name] = func;
	  };
	}

	var calc = new Calculator;

	calc.addMethod("*", function(a, b) {
	  return a * b;
	});
	calc.addMethod("/", function(a, b) {
	  return a / b;
	});
	calc.addMethod("**", function(a, b) {
	  return Math.pow(a, b);
	});

	var result = calc.calculate("2 ** 3");
	alert( result ); // 8
	</script>

<!-- Дескрипторы -->
	<script>
	// Пример простого дескриптора -------------------------------------------------------------------
		//Оба вызова добавляют в объект user обычное (удаляемое, изменяемое, перечисляемое) свойство.
		var user = {};

		// 1. простое присваивание
		user.name = "Вася";

		// 2. указание значения через дескриптор
		Object.defineProperty(user, "name", { 
			value: "Вася", 
			configurable: true, 
			writable: true, 
			enumerable: true 
		});

	// Неудаляемое и неизменяемое свойство объекта ---------------------------------------------------
		"use strict";
		var user = {};

		Object.defineProperty(user, "name", {
		  value: "Вася",
		  writable: false, // запретить присвоение "user.name="
		  configurable: false // запретить удаление "delete user.name"
		});

		// Теперь попытаемся изменить это свойство.
		// в strict mode присвоение "user.name=" вызовет ошибку
		user.name = "Петя";	

	// Свойство, скрытое для for…in ------------------------------------------------------------------
		var user = {
		  name: "Вася",
		  toString: function() { return this.name; }
		};

		// помечаем toString как не подлежащий перебору в for..in
		Object.defineProperty(user, "toString", {enumerable: false});

		for(var key in user) alert(key);  // name

	// Свойство-функция. get и set -------------------------------------------------------------------
		var user = {
		  firstName: "Вася",
		  surname: "Петров"
		}

		Object.defineProperty(user, "fullName", {

			//создаём свойство user.fullName
		  	get: function() {
		   	 	return this.firstName + ' ' + this.surname;
		  	},

		  	//перезаписываем свойство user.fullName
		  	set: function(value) {
		      	var split = value.split(' ');
		      	this.firstName = split[0];
		      	this.surname = split[1];
		    }
		});

		user.fullName = "Петя Иванов";
		alert( user.firstName ); // Петя
		alert( user.surname ); // Иванов

	// Указание get/set в литералах ------------------------------------------------------------------
		var user = {
		  firstName: "Вася",
		  surname: "Петров",

		  get fullName() {
		    return this.firstName + ' ' + this.surname;
		  },

		  set fullName(value) {
		    var split = value.split(' ');
		    this.firstName = split[0];
		    this.surname = split[1];
		  }
		};

		alert( user.fullName ); // Вася Петров (из геттера)

		user.fullName = "Петя Иванов";
		alert( user.firstName ); // Петя  (поставил сеттер)
		alert( user.surname ); // Иванов (поставил сеттер)

 	// Добавление свойств объекту. Object.defineProperties(obj, descriptors)	------------------------
		var user = {}

		Object.defineProperties(user, {
		  firstName: {
		    value: "Петя"
		  },

		  surname: {
		    value: "Иванов"
		  },

		  fullName: {
		    get: function() {
		      return this.firstName + ' ' + this.surname;
		    }
		  }
		});

		alert( user.fullName ); // Петя Иванов

	// Возращение всех свойств. Object.keys(obj), Object.getOwnPropertyNames(obj) ------------------
		var obj = {
		  a: 1,
		  b: 2,
		  internal: 3
		};

		Object.defineProperty(obj, "internal", {
		  enumerable: false
		});

		alert( Object.keys(obj) ); // a,b
		alert( Object.getOwnPropertyNames(obj) ); // a, internal, b
		
	// Возращение дескриптора. Object.getOwnPropertyDescriptor(obj, prop) --------------------------
		var obj = {
		  test: 5
		};
		var descriptor = Object.getOwnPropertyDescriptor(obj, 'test');

		// заменим value на геттер, для этого...
		delete descriptor.value; // ..нужно убрать value/writable
		delete descriptor.writable;
		descriptor.get = function() { // и поставить get
		  alert( "Preved :)" );
		};

		// поставим новое свойство вместо старого

		// если не удалить - defineProperty объединит старый дескриптор с новым
		delete obj.test;

		Object.defineProperty(obj, 'test', descriptor);

		obj.test; // Preved :)

	// z. Добавление свойств, изменение свойств. -----------------------------------------------------
		"use strict"

		function User(fullName) {
		  this.fullName = fullName;

		  Object.defineProperties(this, {

		    firstName: {

		      get: function() {
		      	//разделяем fullName и возращаем первый элемент
		        return this.fullName.split(' ')[0];
		      },
		      //перезаписать свойство
		      set: function(newFirstName) {
		        this.fullName = newFirstName + ' ' + this.lastName;
		      }

		    },

		    lastName: {

		      get: function() {
		      	//разделяем fullname и возращаем второй элемент
		        return this.fullName.split(' ')[1];
		      },

		      set: function(newLastName) {
		        this.fullName = this.firstName + ' ' + newLastName;
		      }

		    }

		  });
		}

		var vasya = new User("Василий Попкин");

		// чтение firstName/lastName
		alert( vasya.firstName ); // Василий
		alert( vasya.lastName ); // Попкин

		// запись в lastName
		vasya.lastName = 'Сидоров';

		alert( vasya.fullName ); // Василий Сидоров
	</script>

<!-- Статические и фабричные методы -->
	<script>
	// Статические свойства и методы ---------------------------------------------------------------
		function Article() {
		  Article.count++;

		  //...
		}

		//статическое свойство
		Article.count = 0;

		//статический метод
		Article.showCount = function() {
		  alert( this.count ); // (1)
		}

		// использование
		new Article();
		new Article();
		Article.showCount(); // (2)
 
 	// Сравнение двух объектов по дате -------------------------------------------------------------
		//В примере ниже эта функция используется для поиска самого раннего журнала из массива:
		function Journal(date) {
		  this.date = date;

		  this.formatDate = function(date) {
		    return date.getDate() + '.' + (date.getMonth() + 1) + '.' + date.getFullYear();
		  };

		  this.getTitle = function() {
		    return "Выпуск от " + this.formatDate(this.date);
		  };

		}

		Journal.compare = function(journalA, journalB) {
		  return journalA.date - journalB.date;
		};

		// использование:
		var journals = [
		  new Journal(new Date(2012, 1, 1)),
		  new Journal(new Date(2012, 0, 1)),
		  new Journal(new Date(2011, 11, 1))
		];

		function findMin(journals) {
		  var min = 0;
		  for (var i = 0; i < journals.length; i++) {
		    // используем статический метод
		    if (Journal.compare(journals[min], journals[i]) > 0) min = i;
		  }
		  return journals[min];
		}

		alert( findMin(journals).getTitle() );

	// Статические свойства без использования объектов ---------------------------------------------
		function Journal() { /*...*/ }

		Journal.formatDate = function(date) {
		  return date.getDate() + '.' + (date.getMonth()+1) + '.' + date.getFullYear();
		}

		// ни одного объекта Journal нет, просто форматируем дату
		alert( Journal.formatDate(new Date) );

	// Фабричные методы
		var str = String.fromCharCode(65);
		alert( str ); // 'A'

	// Фабричные свойства и методы. Пример посложнее -----------------------------------------------
		// Допустим, нам нужно создавать объекты User: анонимные new User() и 
		// с данными new User({name: 'Вася', age: 25}).
		function User() {
		  this.sayHi = function() {
		    alert(this.name)
		  };
		}

		User.createAnonymous = function() {
		  var user = new User;
		  user.name = 'Аноним';
		  return user;
		}

		User.createFromData = function(userData) {
		  var user = new User;
		  user.name = userData.name;
		  user.age = userData.age;
		  return user;
		}

		// Использование

		var guest = User.createAnonymous();
		guest.sayHi(); // Аноним

		var knownUser = User.createFromData({
		  name: 'Вася',
		  age: 25
		});
		knownUser.sayHi(); // Вася

	// Счётчик объектов через статичное свойство и метод ---------------------------------------------
		function Article() {
		  this.created = new Date;

		  Article.count++; // увеличиваем счетчик при каждом вызове
		  Article.last = this.created; // и запоминаем дату
		}
		Article.count = 0; // начальное значение
		// (нельзя оставить undefined, т.к. Article.count++ будет NaN)

		Article.showStats = function() {
		  alert( 'Всего: ' + this.count + ', Последняя: ' + this.last );
		};

		new Article();
		new Article();

		Article.showStats(); // Всего: 2, Последняя: (дата)

		new Article();

		Article.showStats(); // Всего: 3, Последняя: (дата)

	</script>

<!-- Формат JSON -->
 	<script>
	/*
	Данный формат не поддерживает коментарьев, должен строго писатся в двойных кавычках.
	*/

	// Общий примерчик с 2 методами. кс[JSON.parse, JSON.stringify] ----------------------------------
		"use strict";

		var leader = {
		  name: "Василий Иванович",
		  age: 35
		};

		//преобразуем в объект. Метод JSON.parse
		var result = JSON.stringify(leader); 
		console.log( result ); //{"name":"Василий Иванович","age":35}

		//преобразуем в строку. Метод JSON.stringify
		result = JSON.parse(result);  
		console.log( result ); //Object {name: "Василий Иванович", age: 35}

	//Пример 1. --------------------------------------------------------------------//Метод JSON.parse
		var numbers = "[0, 1, 2, 3]";
		numbers = JSON.parse(numbers);
		alert( numbers[1] ); // 1
	
	//Пример 2. --------------------------------------------------------------------//Метод JSON.parse
		var user = '{ "name": "Вася", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';
		user = JSON.parse(user);
		alert( user.friends[1] ); // 1
	
	//Пример 3. --------------------------------------------------------------------//Метод JSON.parse
		name: "Вася",       // ошибка: ключ name без кавычек!
	  "surname": 'Петров',// ошибка: одинарные кавычки у значения 'Петров'!
	  "age": 35,           // .. а тут всё в порядке.
	  "isAdmin": false    // и тут тоже всё ок

	//Преоброзование формата JSON в объект JS. -------------------------------------//Метод JSON.parse
		// дата в строке - в формате UTC
		var str = '{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}';

		var event = JSON.parse(str, function(key, value) {
		  if (key == 'date') return new Date(value);
		  return value;
		});

		alert( event.date.getDate() ); // 30

	//Преоброзование для вложенных объектов ----------------------------------------//Метод JSON.parse
		var schedule = '{ \
		  "events": [ \
		    {"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}, \
		    {"title":"День рождения","date":"2015-04-18T12:00:00.000Z"} \
		  ]\
		}';

		schedule = JSON.parse(schedule, function(key, value) {
		  if (key == 'date') return new Date(value);
		  return value;
		});

		alert( schedule.events[1].date.getDate() );	// 18

	//Сериализация(преоброзование) значение в JSON строку, пример 1. -----------//Метод JSON.stringify
		var event = {
		  title: "Конференция",
		  date: "сегодня"
		};

		var str = JSON.stringify(event);
		alert( str ); // {"title":"Конференция","date":"сегодня"}

		// Обратное преобразование.
		event = JSON.parse(str);

	//Сериализация(преоброзование) значение в JSON строку, пример 2. -----------//Метод JSON.stringify
		var room = {
		  number: 23,
		  occupy: function() {
		    alert( this.number );
		  }
		};

		event = {
		  title: "Конференция",
		  date: new Date(Date.UTC(2014, 0, 1)),
		  room: room
		};

		alert( JSON.stringify(event) );
		/*
		  {
		    "title":"Конференция",
		    "date":"2014-01-01T00:00:00.000Z",  // (1)
		    "room": {"number":23}               // (2) //сериализуем свойства
		  }
		*/
	
	//Исключение свойств. Если их не много. ------------------------------------//Метод JSON.stringify
		var user = {
		  name: "Вася",
		  age: 25,
		  window: window
		};

		alert( JSON.stringify(user, ["name", "age"]) );
		// {"name":"Вася","age":25}

	//Исключение свойств. Если их много. ---------------------------------------//Метод JSON.stringify
		var user = {
		  name: "Вася",
		  age: 25,
		  window: window
		};

		var str = JSON.stringify(user, function(key, value) {
		  if (key == 'window') return undefined;
		  return value;
		});

		alert( str ); // {"name":"Вася","age":25}
		/*
		В примере выше функция пропустит свойство с названием window. Для остальных она просто 
		возвращает значение, передавая его стандартному алгоритму. А могла бы и как-то обработать.
 		*/

 	//Форматирование. ----------------------------------------------------------//Метод JSON.stringify
		var user = {
		  name: "Вася",
		  age: 25,
		  roles: {
		    isAdmin: false,
		    isEditor: true
		  }
		};

		var str = JSON.stringify(user, "", 4);

		alert( str );
		/* Результат -- красиво сериализованный объект:
		{
		    "name": "Вася",
		    "age": 25,
		    "roles": {
		        "isAdmin": false,
		        "isEditor": true
		    }
		}
		*/
	
	//JSON и работа с ссылками. Формат JSON не предусматривает средств для хранения ссылок! ----------
		
		//задача-------------------------------------------------
		var leader = {
		  name: "Василий Иванович"
		};

		var soldier = {
		  name: "Петька"
		};

		// эти объекты ссылаются друг на друга!
		leader.soldier = soldier;
		soldier.leader = leader;

		var team = [leader, soldier];

		//решение 1. Со своей функцией---------------------------
		team.toJSON = function() {
		  /* свой код, который может создавать копию объекта без круговых ссылок и передавать управление 
		  JSON.stringify */
		}
	
		//решение 2. Ссылки заменить на id. ---------------------
		var leader = {
		  id: 12,
		  name: "Василий Иванович"
		};

		var soldier = {
		  id: 51,
		  name: "Петька"
		};

		// поменяли прямую ссылку на ID
		leader.soldierId = 51;
		soldier.leaderId = 12;

		var team = {
		  12: leader,
		  51: soldier
		};

		/*решение 3. ---------------------------------------------
		Использовать особую реализацию JSON которая не входит в реализацию, к примеру 
		фреймворк Dojo.	методом dojox.json.ref.toJson(team) получаем:
		[{"name":"Василий Иванович","soldier":{"name":"Петька","leader":{"$ref":"#0"}}},{"$ref":"#0.soldier"}]
		методом dojox.json.ref.fromJson выводим */
	</script>

<!-- Таймаут и интервалы. setTimeout и setInterval -->
	<script>

	// Вызов func() через одну секунду ---------------------------------------------------------------
		function func() {
		  alert( 'Привет' );
		}
		setTimeout(func, 1000);

	// Вызов анонимной функции через секунду.  -------------------------------------------------------
		setTimeout("alert('Привет')", 1000); // Строи не рекомендуется использовать!
		setTimeout(function() { alert('Привет') }, 1000); // Лучше так

	// Вызов func() через одну секунду. С передачей аргументов (не сработает в IE9-)------------------
		function func(phrase, who) {
		  alert( phrase + ', ' + who );
		}

		setTimeout(func, 1000, "Привет", "Вася"); // Привет, Вася

	// Создание и отмета таймера ---------------------------------------------------------------------
	var timerId = setTimeout(function() { alert(1) }, 1000); 

	clearTimeout(timerId);
	alert(timerId); // всё ещё число, оно не обнуляется после отмены

	// выводить сообщение каждые две секунды, пока не пройдёт 5 секунд -------------------------------
		// начать повторы с интервалом 2 сек
		var timerId = setInterval(function() {
		  alert( "тик" );
		}, 2000);

		// через 5 сек остановить повторы
		setTimeout(function() {
		  clearInterval(timerId);
		  alert( 'стоп' );
		}, 5000);

	// Важная альтернатива setInterval – рекурсивный setTimeout. -------------------------------------
		/** вместо:
		var timerId = setInterval(function() {
		  alert( "тик" );
		}, 2000);
		*/
		var timerId = setTimeout(function tick() {
		  alert( "тик" );
		  timerId = setTimeout(tick, 2000);
		}, 2000);

	//z. Вывод чисел каждые 100 мс ----------------------------------------------------кс[setInterval]
		function printNumbersInterval() {
		  var i = 1;
		  var timerId = setInterval(function() {
		    console.log(i);
		    if (i == 20) clearInterval(timerId);
		    i++;
		  }, 100);
		}
		printNumbersInterval();

	//z. Вывод чисел каждые 100мс ------------------------------------------------------кс[setTimeout]
		function printNumbersTimeout20_100() {
		  var i = 1;
		  var timerId = setTimeout(function go() {
		    console.log(i);
		    if (i < 20) setTimeout(go, 100);
		    i++;
		  }, 100);
		}
		printNumbersTimeout20_100(); 

	!!!//z. Функция-задержка --------------------------------------------кс[setTimeout, apply, декоратор]
		function delay(f, ms) {

		  return function() {
		    var savedThis = this;
		    var savedArgs = arguments;

		    setTimeout(function() {
		      f.apply(savedThis, savedArgs);
		    }, ms);
		  };

		}

		function f(x) {
		  alert( x );
		}

		var f1000 = delay(f, 1000); 
		var f1500 = delay(f, 1500);

		f1000("тест"); // выведет "тест" через 1000 миллисекунд
		f1500("тест2"); // выведет "тест2" через 1500 миллисекунд

	//z. Вызов не чаще чем в N миллисекунд-----------кс[setTimeout, декоратор, apply, this, arguments]
		function debounce(f, ms) {

		  var state = null;

		  var COOLDOWN = 1;

		  return function() {
		    if (state) return; //если state чемуто равно, не Null, завершить
		    //иначе оборачиваем функцию f
		    f.apply(this, arguments);
		    //ставим флаг
		    state = COOLDOWN;
		    //отмеряем время после выполнения функции
		    setTimeout(function() { state = null }, ms);
		  }

		}

		function f(x) { alert(x) }
		var f = debounce(f, 1000);

		f(1); // 1, выполнится сразу же
		f(2); // игнор

		setTimeout( function() { f(3) }, 100); // игнор (прошло только 100 мс)
		setTimeout( function() { f(4) }, 1100); // 4, выполнится
		setTimeout( function() { f(5) }, 1500); // игнор

	//z. Тормозилка ---------------------------------кс[setTimeout, декоратор, apply, this, arguments]
	/*
	По замыслу, надо обрабатывать большое количество кода, при движении мыши. Чтобы не грузить 
	процессор обновление инф будет происходить не без остановочно а предположительно каждые 100мс,
	все полученные промежуточные значения игнорируются и обязательно обрабатывается последние 
	значения.
	*/

		function throttle(func, ms) {

		  var isThrottled = false,
		    savedArgs,
		    savedThis;

		  function wrapper() {

		    if (isThrottled) { // (2)
		      savedArgs = arguments;
		      savedThis = this;
		      return;
		    }

		    func.apply(this, arguments); // (1)

		    isThrottled = true;

		    setTimeout(function() {
		      isThrottled = false; // (3)
		      if (savedArgs) {
		        wrapper.apply(savedThis, savedArgs);
		        savedArgs = savedThis = null;
		      }
		    }, ms);
		  }

		  return wrapper;
		}
	</script>

	<!-- Обработка ошибок. try..catch -->
	<script>

	//Схема try...catch -----------------------------------------------------кс[try...catch...finally]
		try {
		   .. пробуем выполнить код ..
		} catch(e) { //используя finally то catch можно пропустить
		   .. перехватываем исключение ..
		} finally { //finally не обязательная секция
		   .. выполняем всегда ..
		}

	//Простой пример использования try...catch, без ошибок. ---------------------------кс[try...catch]
		try {
		  alert('Начало блока try');  // (1) <--
		  // .. код без ошибок
		  alert('Конец блока try');   // (2) <--
			} catch(e) {
			  alert('Блок catch не получит управление, так как нет ошибок'); // (3)
		}
		alert("Потом код продолжит выполнение...");

	//Пример испльзования, с ошибкой. -------------------------------------------------кс[try...catch]
		try {
		  alert('Начало блока try');  // (1) <--
		  lalala; // ошибка, переменная не определена!
		  alert('Конец блока try');  // (2)
		} catch(e) {
		  alert('Ошибка ' + e.name + ":" + e.message + "\n" + e.stack); // (3) <--
		}
		alert("Потом код продолжит выполнение...");

	//Пример посложнее. Вместо алерта можно много что придумать. ----------------------кс[try...catch]
		var data = "Has Error"; // в данных ошибка
		try {
		  var user = JSON.parse(data); // <-- ошибка при выполнении
		  alert( user.name ); // не сработает
		} catch (e) {
		  // ...выполнится catch
		  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз" );
		  alert( e.name );
		  alert( e.message );
		}

	//«проброс исключения» ----------------------------------------кс[try...catch, throw, SyntaxError]
		//В примере ниже catch обрабатывает только ошибки SyntaxError, а остальные – выбрасывает дальше
		var data = '{ "name": "Вася", "age": 30 }'; // данные корректны
		try {
		  var user = JSON.parse(data);
		  if (!user.name) {
		    throw new SyntaxError("Ошибка в данных");
		  }
		  blabla(); // произошла непредусмотренная ошибка
		  alert( user.name );
		} catch (e) {
		  if (e.name == "SyntaxError") {
		    alert( "Извините, в данных ошибка" );
		  } else {
		    throw e;
		  }
		}
		//Заметим, что ошибка, которая возникла внутри блока catch, «выпадает» наружу

	//"Проброс исключения"-----------------------------------------кс[try...catch, throw, SyntaxError]
		//try..catch внутри readData умеет обрабатывать только SyntaxError, а внешний – все ошибки.
		//Без внешнего проброшенная ошибка «вывалилась» бы в консоль, с остановкой скрипта
			function readData() {
		  var data = '{ "name": "Вася", "age": 30 }';
		  try {
		    // ...
		    blabla(); // ошибка!
		  } catch (e) {
		    // ...
		    if (e.name != 'SyntaxError') {
		      throw e; // пробрасываем
		    }
		  }
		}

		try {
		  readData();
		} catch (e) {
		  alert( "Поймал во внешнем catch: " + e ); // ловим
		}

	//"Оборачивание исключений" как бы заворачивая их в ReadError. кс[try...catch, throw, SyntaxError] 
		function ReadError(message, cause) {
		  this.message = message;
		  this.cause = cause;
		  this.name = 'ReadError';
		  this.stack = cause.stack;
		}

		function readData() {
		  var data = '{ bad data }';

		  try {
		    // ...
		    JSON.parse(data);
		    // ...
		  } catch (e) {
		    // ...
		    if (e.name == 'URIError') {
		      throw new ReadError("Ошибка в URI", e);
		    } else if (e.name == 'SyntaxError') {
		      throw new ReadError("Синтаксическая ошибка в данных", e);
		    } else {
		      throw e; // пробрасываем
		    }
		  }
		}

		try {
		  readData();
		} catch (e) {
		  if (e.name == 'ReadError') {
		    alert( e.message );
		    alert( e.cause ); // оригинальная ошибка-причина
		  } else {
		    throw e;
		  }
		}

	//z. Eval-калькулятор с ошибками ------------------------------------------ кс[try...catch, throw]
		var expr, res;

		while (true) {
		  expr = prompt("Введите выражение?", '2-');
		  if (expr == null) break;

		  try {
		    res = eval(expr);
		    if (isNaN(res)) {
		      throw new Error("Результат неопределён"); //свои исключения
		    }

		    break;
		  } catch (e) {
		    alert( "Ошибка: " + e.message + ", повторите ввод" );
		  }
		}

		alert( res );
	</script>
<!-- 	пример вывода в див с id=parent
	<script>
		document.getElementById('parent').innerHTML = n;
	</script> 
-->
</body>
</html>