### ОБЪЕКТЫ ###

	+Конструктор Object создаёт объект-обёртку.
		Синтакс: // Инициализатор объекта или литерал
		{ [ nameValuePair1[, nameValuePair2[, ...nameValuePairN] ] ] }

		// Вызов в качестве конструктора
		new Object([value])
		
### СВОЙСТВА ###

	+Свойство Object.prototype представляет объект прототипа Object.

	+Свойство Object.prototype.constructor, Возвращает ссылку на функцию Object, создавшую прототип экземпляра. Обратите внимание, что значение этого свойства является ссылкой на саму функцию, а не строкой, содержащей имя функции. Для примитивных значений, вроде 1, true или "test", значение доступно только для чтения.
		Синтакс: var o = {};
		o.constructor === Object; // true

		var a = [];
		a.constructor === Array; // true

		var n = new Number(3);
		n.constructor === Number; // true
		
	-Свойство __count__ использовалось для хранения количества перечисляемых свойств объекта, но было удалено.

	-Свойство __noSuchMethod__ ссылается на функцию, выполняющуюся каждый раз при вызове на объекте несуществующего метода.

	-Свойство __parent__ использовалось для указания контекста объекта, но было удалено.

	+Свойство __proto__ объекта Object.prototype является свойством доступа (комбинацией геттера и сеттера), которые расширяют внутренний прототип [[Prototype]] объекта (являющийся объектом или null), через который осуществлялся доступ.
		Синтакс: var shape = {}, circle = new Circle();
		// Установка прототипа объекта
		shape.__proto__ = circle;
		// Получение прототипа объекта
		console.log(shape.__proto__ === circle); // true

### МЕТОДЫ ###

	+Метод Object.assign() используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.
		Синтакс: Object.assign(target, ...sources)

	+Метод Object.create() создаёт новый объект с указанными объектом прототипа и свойствами.
		Синтакс: Object.create(proto[, propertiesObject])

	+Метод Object.defineProperties() определяет новые или изменяет существующие свойства, непосредственно на объекте, возвращая этот объект.
		Синтакс: Object.defineProperties(obj, props)

	+Метод Object.defineProperty() определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект.

	?The Object.entries() method returns an array of a given object's own enumerable property [key, value] pairs, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).

	+Метод Object.freeze() замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.
		Синтакс: Object.freeze(obj)

	+Метод Object.getOwnPropertyDescriptor() возвращает дескриптор свойства для собственного свойства (то есть такого, которое находится непосредственно в объекте, а не получено через цепочку прототипов) переданного объекта.
		Синтакс: Object.getOwnPropertyDescriptor(obj, prop)

	+Метод Object.getOwnPropertyNames() возвращает массив со всеми свойствами (независимо от того, перечисляемые они или нет), найденными непосредственно в переданном объекте.
		Синтакс: Object.getOwnPropertyNames(obj)
	
	?Метод Object.getOwnPropertySymbols() возвращает массив всех символьных свойств, найденных непосредственно на переданном объекте.
		Синтакс: Object.getOwnPropertySymbols(obj)

	+Метод Object.getPrototypeOf() возвращает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта.
		Синтакс: Object.getPrototypeOf(obj)

	+Метод Object.is() определяет, являются ли два значения одинаковыми значениями.
		Синтакс: var isSame = Object.is(value1, value2);
	?Метод Object.isExtensible() определяет, является ли объект расширяемым (то есть, можно ли к нему добавлять новые свойства).
		Синтакс: Object.isExtensible(obj)

	+Метод Object.isFrozen() определяет, был ли объект заморожен.
		Синтакс: Object.isFrozen(obj)

	+Метод Object.isSealed() определяет, является ли объект запечатанным.
		Синтакс: Object.isSealed(obj)

	+Метод Object.keys() возвращает массив из собственных перечисляемых свойств переданного объекта, в том же порядке, в котором они бы обходились циклом for...in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов).
		Синтакс: Object.keys(obj)
	?Метод Object.observe() используется для асинхронного обзора изменений в объекте. Он предоставляет поток изменений в порядке их возникновения.
		Синтакс: Object.observe(obj, callback)

	+Метод Object.preventExtensions() предотвращает добавление новых свойств к объекту (то есть, предотвращает расширение этого объекта в будущем).
		Синтакс: Object.preventExtensions(obj)

	+Метод __defineGetter__() привязывает свойство объекта к функции, вызываемой каждый раз при поиске этого свойства.

	+Метод __defineSetter__() привязывает свойство объекта к функции, вызываемой каждый раз при попытке установить значение этого свойства.

	+Метод __lookupGetter__() возвращает функцию, привязанную к геттеру указанного свойства.

	+Метод __lookupSetter__() возвращает функцию, привязанную к сеттеру указанного свойства.

	-Метод Object.eval() использовался для вычисления строки JavaScript-кода в контексте объекта, однако, был удалён.

	+Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство.
		Синтакс: obj.hasOwnProperty(prop)

	+Метод isPrototypeOf() проверяет, входит ли объект в цепочку прототипов другого объекта.
		Синтакс: prototypeObj.isPrototypeOf(obj)

	+Метод propertyIsEnumerable() возвращает логическое значение, указывающее, является ли указанное свойство перечисляемым.
		Синтакс: obj.propertyIsEnumerable(prop)

	+Метод toLocaleString() возвращает строку, представляющую объект. Этот метод предназначен для переопределения унаследованными объектами в целях поддержки зависимости от локали.

	-Метод toSource() возвращает строку, представляющую исходный код объекта.

	+Метод toString() возвращает строку, представляющую объект.
		Синтакс: obj.toString()

	-Метод unwatch() удаляет точку наблюдения, установленную методом watch().

	+Метод valueOf() возвращает примитивное значение указанного объекта.
		Синтакс: object.valueOf()

	-Метод watch() следит за присваиванием свойству значений и запускает указанную функцию, когда это происходит.

	+Метод Object.seal() запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми.
		Синтакс: Object.seal(obj)

	-Метод Object.setPrototype() устанавливает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта в другой объект или null.


## Object ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//--- Базовое понятие. -------------------------------------------------------------------------+
//--- Свойства объекта, доступ через[]. --------------------------------------------------------+
//--- Свойства объекта, доступ. ----------------------------------------------------------------+
//--- Свойства объекта, создание ---------------------------------------------------------------+
//--- Свойство объекта, задать значение. -------------------------------------------------------+
//--- Свойство объекта, перебор | key in... ----------------------------------------------------+
//--- Свойства объекта, перебор | Метод Object.keys(obj). --------------------------------------+
//--- Свойство объекта, перебор | В: ключь + значение. -----------------------------------------+
//--- z. Вывести сумму свойств объекта. --------------------------------------------------------+
//--- Преоброзования. --------------------------------------------------------------------------+
//--- Свойства. Какими они бывают. -------------------------------------------------------------+
//--- Создание пустого объекта. | Object.create(null). -----------------------------------------+
//--- z.Аргументы по умолчанию. ----------------------------------------------------------------+
//--- Клонирование объекта. --------------------------------------------------------------------+
//--- Коллекция элементов, перебор, задать всем значение ---------------------------------------+
//--- Свойства объекта, сортировка, сравнение. -------------------------------------------------+
//--- Свойства объекта, копирование из одного объекта в пустой другой. -------------------------+
//--- new | Функция-конструктор. ---------------------------------------------------------------+
//--- new | Функция-конструктор, объявление и использование. (для сложн вычисл) ----------------+
//--- new | Особенности return(а). -------------------------------------------------------------+
//--- new | Создание методов в конструкторе ----------------------------------------------------+
//--- new | Локальная(вспомогательная) переменная и функция. -----------------------------------+
//--- z. new | Калькулятор через new и this. ---------------------------------------------------+
//--- z. new | Сумма значений через new. -------------------------------------------------------+
	
	//--- Базовое понятие. -------------------------------------------------------------------------+
		var person = {}; // пока пустой
		person.name = 'Вася';
		person.age = 25;
		alert( person.name + ': ' + person.age ); // "Вася: 25"
		delete person.age; //удаляем свойство age
		//проверяем свойства объекта person, способ 1
		alert( person.lalala === undefined ); // true, свойства нет
		alert( person.name === undefined ); // false, свойство есть.
		//проверяем свойства объекта person, способ 2
		var obj = {};
		obj.test = undefined;
		alert( "test" in obj ); // true
		alert( "blabla" in obj ); // false
	
	//--- Свойства объекта, доступ через[]. --------------------------------------------------------+
		var person = {};
		person['name'] = 'Вася'; // то же что и person.name = 'Вася'
		var person = {};
		person['любимый стиль музыки'] = 'Джаз';
	
	//--- Свойства объекта, доступ. ----------------------------------------------------------------+
		var person = {};
		person.age = 25;
		var key = 'age';
		alert( person[key] ); // выведет person['age']
	
	//--- Свойства объекта, создание ---------------------------------------------------------------+
		var menuSetup = {
		  width: 300,
		  height: 200,
		  title: "Menu"
		};
		// то же самое, что:
		var menuSetup = {};
		menuSetup.width = 300;
		menuSetup.height = 200;
		menuSetup.title = 'Menu';
	
	//--- Свойство объекта, задать значение. -------------------------------------------------------+
		var user = {
		  name: "Таня",
		  age: 25,
		  size: {
		    top: 90,
		    middle: 60,
		    bottom: 90
		  }
		}
		alert(user.name) // "Таня"
		alert(user.size.top) // 90
	
	//--- Свойство объекта, перебор | key in... ----------------------------------------------------+
		for (key in obj) {
		  /* ... делать что-то с obj[key] ... */
		}
	
	//--- Свойства объекта, перебор | Метод Object.keys(obj). --------------------------------------+
		var user = {
		  name: "Петя",
		  age: 30
		}
		var keys = Object.keys(user);
		alert( keys ); // name, age
	
	//--- Свойство объекта, перебор | В: ключь + значение. -----------------------------------------+
		var menu = {
		  width: 300,
		  height: 200,
		  title: "Menu"
		};
		for (var key in menu) {
		  // этот код будет вызван для каждого свойства объекта
		  // ..и выведет имя свойства и его значение
		  alert( "Ключ: " + key + " значение: " + menu[key] );
		}
    
    //--- z. Вывести сумму свойств объекта. --------------------------------------------------------+
		"use strict";
		var salaries = {
		  "Вася": 100,
		  "Петя": 300,
		  "Даша": 250
		};
		var sum = 0;
		for (var name in salaries) {
		  sum += salaries[name];
		}
		alert( sum );
	
	//--- Преоброзования. --------------------------------------------------------------------------+
		var room = {
		  number: 777,

		  valueOf: function() { return this.number; }, //численное преоброзование
		  toString: function() { return this.number; } //строковое преоброзование
		};

		console.log( +room );  // 777, вызвался valueOf

		delete room.valueOf; // valueOf удалён

		console.log( +room );  // 777, вызвался toString
	
	//--- Свойства. Какими они бывают. -------------------------------------------------------------+

		function Calculator() {

			// 1) Способ
			Calculator.property = function (value) { ... } //свойство "property"

		 	// 2) Способ, через this
			this.property = function(str) { ... } //свойство "calculate" 

			// 3) Способ. Они могут быть вложенными в объект
		  	var methods = { //хранит в себе два свойства
		    	"-": function(a, b) { ... }, //свойство "-"
		    	"+": function(a, b) { ... }; //свойство "+"

		  	// 4) Способ. Добавление
		  	var methods = { ... }
		  
		  	this.addMethod = function(name, func) {
		  		methods[name] = func;
		  	};  
		}
	
	//--- Создание пустого объекта. | Object.create(null). -----------------------------------------+
	  	var data = Object.create(null);
	  	data.text = "Привет";

	  	alert(data.text); // Привет
	  	alert(data.toString); // undefined
	
	//--- z.Аргументы по умолчанию. ----------------------------------------------------------------+
		function Menu(options) {
		  	//создание объекта options позволяет сохранить переданные значения не боясь за то что данные будут изменены. 
		  	//Ещё эту проблему можно было решить с помощью переменных и копированием всего объекта.
		  	options = Object.create(options); //создаём такойже объект.

		  	options.width = options.width || 300;

		  	alert( options.width ); // возьмёт width из наследника
		  	alert( options.height ); // возьмёт height из исходного объекта
		  	...
		}
	
	//--- Клонирование объекта. --------------------------------------------------------------------+
		var user = {
		  name: "Вася",
		  age: 30
		};
		var clone = {}; // новый пустой объект
		// скопируем в него все свойства user
		for (var key in user) {
		  clone[key] = user[key];
		}
		// теперь clone - полностью независимая копия
		clone.name = "Петя"; // поменяли данные в clone
		alert( user.name ); // по-прежнему "Вася"
	
	//--- Коллекция элементов, перебор, задать всем значение ---------------------------------------+
		var store = {}; // объект для коллекции
		var items = ["div", "a", "form"];
		for (var i = 0; i < items.length; i++) {
		  var key = items[i]; // для каждого элемента создаём свойство
		  store[key] = true; // значение здесь не важно
		}
		//В: Object {div: true, a: true, form: true}
	
	//--- Свойства объекта, сортировка, сравнение. -------------------------------------------------+
		// Наша функция сравнения
		function compareAge(personA, personB) {
		  return personA.age - personB.age;
		}

		// проверка
		var vasya = { name: "Вася", age: 23 };
		var masha = { name: "Маша", age: 18 };
		var vovochka = { name: "Вовочка", age: 6 };

		var people = [ vasya , masha , vovochka ];

		people.sort(compareAge);

		// вывести
		for(var i = 0; i < people.length; i++) {
		  alert(people[i].name); // Вовочка Маша Вася
		}
	
	//--- Свойства объекта, копирование из одного объекта в пустой другой. -------------------------+
		var obj1 = { 
			one: 1,
			two: 2,
			three: 3
		} 

		function copy(dst) {
		  // остальные аргументы остаются безымянными
		  for (var i = 1; i < arguments.length; i++) {
		    var arg = arguments[i];
		    for (var key in arg) {
		      dst[key] = arg[key];
		    }
		  }

		  return dst;
		}

		var dst = copy({}, obj1);

		console.log(obj1); //Object {one: 1, two: 2, three: 3}
		console.log(dst); //Object {one: 1, two: 2, three: 3}
	
	//--- new | Функция-конструктор. ---------------------------------------------------------------+
		function Animal(name) {
		  // this = {}; это делает интерпритатор

		  // в this пишем свойства, методы
		  this.name = name;
		  this.canWalk = true;

		  // return this; это делает интерпритатор
		}
		var animal = new Animal("ёжик");
		//результатом будет
		animal = {
		  name: "ёжик",
		  canWalk: true
		}
	
	//--- new | Функция-конструктор, объявление и использование. (для сложн вычисл) ----------------+
		//Применять если нужен только 1объект и сложные вычисления, где нужно исп this.
		var animal = new function() {
		  this.name = "Васька";
		  this.canWalk = true;
		};
	
	//--- new | Особенности return(а). -------------------------------------------------------------+
		function BigAnimal() {
		  this.name = "Мышь";
		  return { name: "Годзилла" };  // <-- возвратим объект
		  //return "Годзилла"; // <-- Допускается и возврат строки. возвратим примитив
		}
		alert( new BigAnimal().name );  // Годзилла, получили объект вместо this
	
	//--- new | Создание методов в конструкторе ----------------------------------------------------+
		function User(name) {
		  	this.name = name;

		  	this.sayHi = function() {
		    	alert( "Моё имя: " + this.name );
		  	};
		}

		var ivan = new User("Иван");

		ivan.sayHi(); // Моё имя: Иван

		/*
		ivan = {
		   name: "Иван",
		   sayHi: функция
		}
		*/
	
	//--- new | Локальная(вспомогательная) переменная и функция. -----------------------------------+
		function User(firstName, lastName) {
		  	// вспомогательная переменная
		  	var phrase = "Привет";

		  	//  вспомогательная вложенная функция
		  	function getFullName() {
		      	return firstName + " " + lastName;
		    }

		  	this.sayHi = function() {
		    	alert( phrase + ", " + getFullName() ); // использование
		  	};
		}

		var vasya = new User("Вася", "Петров");
		vasya.sayHi(); // Привет, Вася Петров
	
	//--- z. new | Калькулятор через new и this. ---------------------------------------------------+
		function Calculator() {

		  this.read = function() {
		    this.a = +prompt('a?', 0);
		    this.b = +prompt('b?', 0);
		  };

		  this.sum = function() {
		    return this.a + this.b;
		  };

		  this.mul = function() {
		    return this.a * this.b;
		  };
		}

		var calculator = new Calculator();
		calculator.read();

		alert( "Сумма=" + calculator.sum() );
		alert( "Произведение=" + calculator.mul() );
	
	//--- z. new | Сумма значений через new. -------------------------------------------------------+
		function Accumulator(startingValue) {
		  	this.value = startingValue;

		  	this.read = function() {
		    	this.value += +prompt('Сколько добавлять будем?', 0);
		  	};

		}

		var accumulator = new Accumulator(1);
		accumulator.read();
		accumulator.read();
		alert( accumulator.value );


## ES6-Object ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//--- Деструктуризация объекта. ----------------------------------------------------------------+
//--- Деструктуризация объекта | Переназначение имени | Значение по умолчанию. -----------------+
//--- Деструктуризация объекта со вложенными объектами и массивами. ----------------------------+
//--- Короткое свойство. -----------------------------------------------------------------------+
//--- Вычисляемые свойства с помощью []. -------------------------------------------------------+
//--- Object.assign | копирование свойств (с перезаписью). -------------------------------------+
//--- Object.assign | одноуровневое копирование объекта. ---------------------------------------+
//--- Object.is(value1, value2)  | проверка равенства значений вместо ===. ---------------------+
//--- Методы объекта. --------------------------------------------------------------------------+
//--- Методы объекта | Вычисляемое название метода. --------------------------------------------+
//--- ключевое слово super | портатим | получение свойства объекта. ----------------------------+
//--- Символы в объектах. ----------------------------------------------------------------------+

	//--- Деструктуризация объекта. ----------------------------------------------------------------+
		let a, b;
		({a, b} = {a:5, b:6}); // ( ) тут важны

	//--- Деструктуризация объекта | Переназначение имени | Значение по умолчанию. -----------------+
		let options = {
		  title: "Меню",
		  width: 100,
		  //height: 200
		};
		let {width: w, height=200, title} = options;
		alert(title);  // Меню
		alert(w);      // 100
		alert(height); // 200

	//--- Деструктуризация объекта со вложенными объектами и массивами. ----------------------------+
		let options = {
		  size: {
		    width: 100,
		    height: 200
		  },
		  items: ["Пончик", "Пирожное"]
		}

		let { title="Меню", size: {width, height}, items: [item1, item2] } = options;

		// Меню 100 200 Пончик Пирожное
		alert(title);  // Меню
		alert(width);  // 100
		alert(height); // 200
		alert(item1);  // Пончик
		alert(item2);  // Пирожное

	//--- Короткое свойство. -----------------------------------------------------------------------+
		let name = "Вася";
		let isAdmin = true;
		let user = {
		  name,
		  isAdmin
		};
		alert( JSON.stringify(user) ); // {"name": "Вася", "isAdmin": true}

	//--- Вычисляемые свойства с помощью []. -------------------------------------------------------+
		/*В качестве имени свойства можно использовать выражение*/
		let propName = "firstName";
		let user = {
		  [propName]: "Вася"
		};
		alert( user.firstName ); // Вася

	//--- Object.assign | копирование свойств (с перезаписью). -------------------------------------+
		let user = { name: "Вася" };
		let visitor = { isAdmin: false, visits: true };
		let admin = { isAdmin: true };
		Object.assign(user, visitor, admin);
		// user <- visitor <- admin
		alert( JSON.stringify(user) ); // name: Вася, visits: true, isAdmin: true

	//--- Object.assign | одноуровневое копирование объекта. ---------------------------------------+
		let user = { name: "Вася", isAdmin: false };
		// clone = пустой объект + все свойства user
		let clone = Object.assign({}, user);

	//--- Object.is(value1, value2)  | проверка равенства значений вместо ===. ---------------------+
		
		alert( Object.is(+0, -0)); // false
		alert( +0 === -0 );        // true

		alert( Object.is(NaN, NaN) ); // true
		alert( NaN === NaN );         // false

	//--- Методы объекта. --------------------------------------------------------------------------+
	    let name = "Вася";
	    let user = {
	      	name,

	      	//вместо этого
	      	// sayHi: function() {
	      	//   alert(this.name);
	      	// }
	  
	        //это
	        sayHi() {
	          alert(this.name);
	        }
	        
	    };
	    user.sayHi(); // Вася

	//--- Методы объекта | Вычисляемое название метода. --------------------------------------------+
		let name = "Вася", surname="Петров";
		let user = {
		  	name,
		  	surname,
		  	get fullName() {
		    	return `${name} ${surname}`;
		  	}
		};
		alert( user.fullName ); // Вася Петров

	//--- ключевое слово super | портатим | получение свойства объекта. ----------------------------+
		let animal = {
		 	walk() {
		    	alert("I'm walking");
		  	}
		};

		let rabbit = {
		  	__proto__: animal,
		  	walk() {
		    	alert(super.walk); // walk() { … }
		    	super.walk(); // I'm walking
		    	/* Или можно так с => в сочетании с setTimeout.
		    	setTimeout(() => super.walk()); // I'm walking */
		  	}
		};

		rabbit.walk();

	//--- Символы в объектах. ----------------------------------------------------------------------+

		//Символы не участвую в итерации (переборе свойств for..in)
			let user = {
			  name: "Вася",
			  age: 30,
			  [Symbol.for("isAdmin")]: true
			};

			// в цикле for..in также не будет символа
			alert( Object.keys(user) ); // name, age

			// доступ к свойству через глобальный символ — работает
			alert( user[Symbol.for("isAdmin")] );

		//Отсутствие конфликта нового системного свойства
			let obj = {
			  iterator: 1,
			  [Symbol.iterator]: function() {}
			}

			// один символ в объекте
			//alert( Object.getOwnPropertySymbols(obj) ); //один из вариантов, но уже не работает 
			alert( Object.getOwnPropertySymbols(obj)[0].toString() ); // Symbol(Symbol.iterator)

			// и одно обычное свойство
			alert( Object.getOwnPropertyNames(obj) ); // iterator



