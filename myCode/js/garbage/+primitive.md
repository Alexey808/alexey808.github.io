## Советы
!Побитовое округление: Это удобно в первую очередь тем, что легко читается и не заставляет ставить дополнительные скобки
!toString(36): При помощи такого кодирования можно «укоротить» длинный цифровой идентификатор, например чтобы выдать его в качестве URL.

## Описания методов 

parseInt (n) - аналог parseFloat, для целых чисел, преобразуют строки в числа/шестнадцатиричные.  
parseFloat (n) - аналог parseInt, для дробных чисел, преобразуют строки в числа.  
isNaN(str) - проверка на число. true если NaN. Важно! false, true, null преобразуются к числам.  
isFinite(n) - преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.  
toString(система счисления) - преобразовывает значение в выбранную систему счисления от 2 до 36
Math.floor(n) - Округляет вниз
Math.ceil(n) - Округляет вверх
Math.round(n) - Округляет до ближайшего целого
num.toFixed(precision) - Округление идёт до ближайшего значения, аналогично Math.round
## Примеры 
```js
/* Проверка */
isNaN(1 + 'a123'); //true, сложение не возможно, результат NaN

/* Преоброзования */
parseInt('12px'); //12
parseInt('FF', 16); // 255
parseFloat('12.3px'); //12.3

var n = 1234567890;
alert( n.toString(36) ); // kf12oi

/* Округления */
Math.floor(3.1);  // 3
Math.ceil(3.1);   // 4
Math.round(3.1);  // 3
//битовые округления
~~12.3; // 12
12.3 ^ 0; // 12
1.2 + 1.3 ^ 0; // 2, приоритет ^ меньше, чем +
```

## Универсальные решения

**Проверка на число или строку**
```js
  function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
  }
```
**Простое кодирование длинных чисел**
```js
  var n = 1234567890;
  alert( n.toString(36) ); // kf12oi
```
**Округление до заданной точности**
```js
  var n = 3.456;
  //способ 1
  alert( +n.toFixed(2) ); // "3.46" //при необходимости, дополняется нулями до нужной точности.
  //способ 2
  alert( Math.round(n * 100) / 100 ); // 3.46 //сколько 0 столько знаков после точки. можн отриц.
```
