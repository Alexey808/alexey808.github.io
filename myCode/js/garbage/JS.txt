http://javascript.ru/manual
библиотека для IE работа с перебором массивов ES5-shim
библиотека Moment.JS для создания своей функции форматирования даты-времени.
Библиотека es5-shim для IE работа с датой-временем. (https://github.com/es-shims/es5-shim)
библиотеки JS:  Lodash, jQuery
фреймворке Dojo


проверка типа
проверка регульрных выражений(вводимое пользователем)

===СОДЕРЖАНИЕ===

Стандартные объекты

    Array - Массив пронумерованных элементов, также может служить стеком или очередью
    Boolean - Объект для булевых значений
    Date - Функции для работы с датой и временем
    Error - объект для представления ошибок
    EvalError - Ошибка при выполнении функции eval
    Function - Каждая функция в яваскрипт является объектом класса Function.
    Math - Встроенный объект, предоставляющий константы и методы для математических вычислений.
    Number - Объект для работы с числами
    Object - Базовый объект javascript
    RangeError - Ошибка, когда число не лежит в нужном диапазоне
    ReferenceError - Ошибку при ссылке на несуществующую переменную
    RegExp - Позволяет работать с регулярными выражениями.
    String - Базовый объект для строк. Позволяет управлять текстовыми строками, форматировать их и выполнять поиск подстрок.
    SyntaxError - Ошибка при интерпретации синтаксически неверного кода
    TypeError - Ошибка в типе значения
    URIError - Ошибка при некорректном URI

Объекты браузера

    window - Два в одном: глобальный объект и окно браузера

Глобальные методы

    alert - Выводит модальное окно с сообщением
    clearInterval - Останавливает выполнение кода, заданное setInterval
    clearTimeout - Отменяет выполнение кода, заданное setTimeout
    confirm - Выводит сообщение в окне с двумя кнопками: "ОК" и "ОТМЕНА" и возвращает выбор посетителя
    decodeURI - Раскодирует URI, закодированный при помощи encodeURI
    decodeURIComponent - Раскодирует URI, закодированный при помощи encodeURIComponent
    encodeURI - Кодирует URI, заменяя каждое вхождение определенных символов на escape-последовательности, представляющие символ в кодировке UTF-8.
    encodeURIComponent - Кодирует компоненту URI, заменяя определенные символы на соответствующие UTF-8 escape-последовательности
    eval - Выполняет строку javascript-кода без привязки к конкретному объекту.
    isFinite - возвращает, является ли аргумент конечным числом
    isNaN - Проверяет, является ли аргумент NaN
    parseFloat - преобразует строковой аргумент в число с плавающей точкой
    parseInt - преобразует строковой аргумент в целое число нужной системы счисления
    prompt - Выводит окно с указанным текстом и полем для пользовательского ввода.
    setInterval - Выполняет код или функцию через указанный интервал времени
    setTimeout - Выполняет код или функцию после указанной задержки

Глобальные свойства

    arguments - Переменная, доступная внутри функции и содержащая аргументы и ссылку на саму функцию.
    document - Отвечает за взаимодействие JavaScript с объектом документа(страницей)
    	Является корневым элементом DOM-дерева страницы (объект типа DOMDocument согласно спецификации DOM)
    Infinity - Бесконечность
    NaN - Не-Числовое значение
    undefined - Обозначает неопределенное значение

Синтаксические конструкции

	break - Завершает текущий цикл или конструкции switch и label и передает управление на следующий вызов
    continue - Прекращает текущую итерацию цикла и продолжает выполнение со следующей итерации
    do..while - Задает цикл с проверкой условия после каждой итерации
    for - Создать цикл, указав начальное состояние, условие и операцию обновления состояния
    for..in - Перебрать свойства объекта, для каждого свойства выполнить заданный код
    function - Объявить функцию
    if - Выполняет тот или иной блок кода в зависимости от того, верно ли условие
    label - Указать идентификатор для использования в break и continue
    return - Возвратить результат работы функции
    switch - Сравнивает значение выражения с различными вариантами и при совпадении выполняет соответствующий код
    throw - Инициировать("бросить") исключение
    try..catch - Ловить все исключения, выпадающие из блока кода
    var - Объявить переменную (или несколько) в текущей области видимости
    while - Задает цикл, который выполняется до тех пор, пока условие верно. Условие проверяется перед каждой итерацией.
    with - Добавить новую область видимости
    Блок - Группировка javascript-вызовов внутри фигурных скобок

Операторы
	
	delete
	function
	in
	instanceof
	new
	this
	typeof
	void


--------------------------------------------------------------------------------
### Строки ### http://javascript.ru/String

Методы

    split
    charCodeAt
    String.fromCharCode
    charAt
    concat
    lastIndexOf
    search
    match
    toLowerCase
    toUpperCase
    toLocaleLowerCase
    toLocaleUpperCase
    toString - строковое преоброзование
    valueOf - числовое преоброзование
    substring
    slice
    indexOf
    substr
    replace

Свойства

    length

### Массивы ### http://javascript.ru/Array

Методы

    push
    shift
    join
    concat
    pop
    unshift
    slice
    reverse
    sort
    splice

Свойства

    index
    input
    length

### Объекты ### http://javascript.ru/Object

Стандартные объекты

Array
Массив пронумерованных элементов, также может служить стеком или очередью
Boolean
Объект для булевых значений
Date
Функции для работы с датой и временем
Error
объект для представления ошибок
EvalError
Ошибка при выполнении функции eval
Function
Каждая функция в яваскрипт является объектом класса Function.
Math
Встроенный объект, предоставляющий константы и методы для математических вычислений.
Number
Объект для работы с числами
Object
Базовый объект javascript
RangeError
Ошибка, когда число не лежит в нужном диапазоне
ReferenceError
Ошибку при ссылке на несуществующую переменную
RegExp
Позволяет работать с регулярными выражениями.
String
Базовый объект для строк. Позволяет управлять текстовыми строками, форматировать их и выполнять поиск подстрок.
SyntaxError
Ошибка при интерпретации синтаксически неверного кода
TypeError
Ошибка в типе значения
URIError
Ошибка при некорректном URI
Объекты браузера

window
Два в одном: глобальный объект и окно браузера
--------------------------------------------------------------------------------
--- Краткость --- 
//короткое орифметическое действие
x += 10 // x = x + 10

//короткое "если"
access = (age > 14) ? true : false;

//короткие функции, в return сразу писать выражение
function () {
    return "длинное выражение";
}


//короткий перебор массива
for (var i=0; i<arr.length; i++)
--------------------------------------------------------------------------------
+-------------------------------------------+
|   Проверка знаний JS                      |
+-------------------------------------------+
|   Write the result of these expressions:  |
|   6 / "3"     // 2                        |
|   "2" * "2"     //4                       |
|   4 + 5 + "4px"    //"94px"               |
|   «$» + 4 + 5                             |
|   «4» — 2                                 |
|   «4px» — 2                               |
|   7 / 0                                   |
|   typeof null                             |
|   typeof {}[0]                            |
|   typeof («4px» — 2)                      |
|   parseInt(«09»)                          |
|   5 && 2                                  |
|   2 && 5                                  |
|   5 || 0                                  |
|   0 || 5                                  |
+-------------------------------------------+
|   * метка, где я допустил ошибки          |
|   "" + 1 + 0          "10"                |
|   "" - 1 + 0          -1                  |
|   true + false        1           *       |
|   6 / "3"             2                   |
|   "2" * "3"           6                   |
|   4 + 5 + "px"        "9px"       *       |
|   "$" + 4 + 5         "$45"               |
|   "4" - 2             2                   |
|   "4px" - 2           NaN                 |
|   7 / 0               Infinity            |
|   "  -9\n" + 5        " -9\n5"    *       |
|   "  -9\n" - 5        -14         *       |
|   5 && 2              2                   |
|   2 && 5              5                   |
|   5 || 0              5                   |
|   0 || 5              5                   |
|   null + 1            1           *       |
|   undefined + 1       NaN         *       |
|   null == "\n0\n"     false               |
|   +null == +"\n0\n"   true                |          
+-------------------------------------------+

+-----------------------------------------------------------------------+
|   Побитовые Операторы                                                 |
+-----------------------------------------------------------------------+
|   AND(и) ( & )                                                        |
|   OR(или) ( | )                                                       |
|   XOR(побитовое исключающее или) ( ^ )                                |
|   NOT(не) ( ~ )                                                       |
|   LEFT SHIFT(левый сдвиг) ( << )                                      |
|   RIGHT SHIFT(правый сдвиг) ( >> )                                    |
|   ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )    |
+-----------------------------------------------------------------------+

+-----------------------------------------------------------------------+
|   Логическое преобразование                                           |
+-----------------------------------------------------------------------+
|   Значение            Преобразуется в...                              |
|   undefined, null     false                                           |
|   Числа               Все true, кроме 0, NaN -- false.                |
|   Строки              Все true, кроме пустой строки "" -- false       |
|   Объекты             Всегда true                                     |
+-----------------------------------------------------------------------+

+---------------------------------
|   Преоброзование объектов
+----------------------------------
|   1) new Date(0) - 0         // = 0
|   2) new Array(1)[0] + ""    // = "undefined"
|   3) ({})[0]                 // = undefined
|   4) [1] + 1                 // = 11
|   5) [1,2] + [3,4]           // = "1,23,4"
|   5) [] + null + 1           // = "null1"
|   6) [[0]][0][0]             // = 0
|   7) ({} + {})               // = "[object Object][object Object]"
|   8) [] == []             // false
|   9) [] == ![]            // true
|      {}[0]                // то же что и: [0]
|      {} + {}              // то же что и: + {}
|
|   1) оператор - дату приоброзовывает в число, а начальная дата начинается с 0 мс.
|   2) new Array(1) создаёт пустой массив из 2 элементов, а при сложении со строкой получается "undefined"
|   3) ({}) создаёт объект, но '0' не будет являтся его свойством. Так что значением будет undefined.
|   4) массив преобразуется в '1' а при сложении строки с числом всё приводится к строке и конкетируется
|   5) Массивы приводятся к строке и складываются, конкакетация.
|   6) Преобразуя массив, получается строка '' после уже всё приводится к строке, конкакетация.
|   7) [[0]] – это вложенный массив [0] внутри внешнего [ ]. Затем мы берём от него нулевой элемент, и потом еще раз.
|   8) Два объекта равны только тогда, когда это один и тот же объект.
|   9) Сначало левая преобразуется в '' а правая в false из за логич оператора не, после всё приводится к строке 0 == 0 
+----------------------------------

+----------------------------------
!Ни счётчик ни реклама не должны загружатся до начала блока боди, чтобы не тормазить ими сайт.
!JS автоматически не ставит ; перед [ скобкой. Рекомендуется самому раставлять все ;
!Особенность бинарного оператора (число+строка)=строка. Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
!для поддержки ES5 в IE можно подключить библиотеку  ES5 shim а именно скрипты es5-shim.js и es5-sham.js
!Директива use strict (строгий режим) позволяет использовать код по новым стандартам. Подключается вначале скрипта кодом "use strict";
!Есть 5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип – объекты object.
!Унарный + преобразует строку в число (var a="2",b="3";alert(+a + +b); вывод 5)
!Значение undefined вообще нельзя сравнивать
!Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).
!При преобразовании в число null становится 0, а undefined становится NaN.
!null и undefined. Они равны друг другу, но не равны чему бы то ни было ещё, этот случай прописан особо в спецификации.
!Принцип дополнения до двойки делит все двоичные представления на два множества: если крайний-левый бит равен 0 – число положительное, если 1 – число отрицательное. Поэтому этот бит называется знаковым битом.
!~ (Побитовое НЕ) Из-за внутреннего представления отрицательных чисел получается так, что ~n == -(n+1).
!Обычно число в JavaScript имеет 64-битный формат с плавающей точкой. При этом часть битов (52) отведены под цифры, часть (11) отведены под хранение номера позиции, на которой стоит десятичная точка, и один бит – знак числа.
!Итак, оператор || вычисляет операнды слева направо до первого «истинного» и возвращает его, а если все ложные – то последнее значение.
!Итак, оператор && вычисляет операнды слева направо до первого «ложного» и возвращает его, а если все истинные – то последнее значение.
!двойное НЕ  (!!"строка" = true или !!null = false)используют для преобразования значений к логическому типу
!Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях > >= < <=.
!Для явного преобразования используется двойное логическое отрицание !!value или вызов Boolean(value).
!Два значения могут быть равны, но одно из них в логическом контексте true, другое – false.
!сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале-конце цикла, а посередине.
!Есть 2 вида объявления функция (Function Declaration и Function Expression), отличия в том что Declaration строится до выполнения основного кода, а Expression во время выполнения основного кода где она и присваивается. Также важно: Function Declaration при use strict видны только внутри блока, в котором объявлены!
!!Если нет явной причины использовать Function Expression – предпочитайте Function Declaration.
!Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на 10000 вложенных вызовов, но некоторые интерпретаторы допускают и больше.
!Рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – ещё к более простому, и так далее, пока значение не станет очевидно.
!!Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
!!Один из показателей хорошего разработчика – качество комментариев, которые позволяют эффективно поддерживать код, возвращаться к нему после любой паузы и легко вносить изменения.
!!Тесты. Как правило, beforeEach/afterEach (before/each) используют, если необходимо произвести инициализацию, обнулить счётчики или сделать что-то ещё в таком духе между тестами (или их группами).
!Все числа в JavaScript, как целые так и дробные, имеют тип Number и хранятся в 64-битном формате IEEE-754, также известном как «double precision».
!Значение NaN – единственное, в своем роде, которое не равно ничему, включая себя. Используется для обозначения математической ошибки.

!В эмуляциях браузеров можно отловить 95% багов, оставшийся 5% нужно тестить в самом браузере.
!Модуль – это всего лишь функция-обёртка для скрытия переменных.

!!this доступ из метода к текущему объекту. Значение this называется контекстом вызова и будет определено в момент вызова функции.
    this > это текущий объект при вызове "через точку"
    this > через "new" новый объект

!!Работа с функциями и свойствами. Любая операция над результатом операции получения свойства, кроме вызова "()" приводит к потере контекста/значения.
!Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.

!В JavaScript вызовы new Boolean/String/Number не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например Boolean(val) === !!val.
!В логическом контексте объект – всегда true.
!! Два объекта равны только тогда, когда это один и тот же объект.
!! Квадратные скобки после массива/объекта обозначают не другой массив, а взятие элемента. [1,[0],2][1]
!!!чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: Animal, а не animal.
!Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в this, который автоматически станет результатом.
!Использование функций для создания объекта дает большую гибкость. Можно передавать конструктору параметры, определяющие как его создавать, и он будет «клепать» объекты заданным образом.
!!полиморфные конструкторы лучше использовать там, где нужен именно полиморфизм, т.е. когда непонятно, какого типа аргумент передадут, и хочется в одном конструкторе охватить все варианты.
!Преимущество apply перед call отчётливо видно, когда мы формируем массив аргументов динамически.
!В современном стандарте call/apply передают this «как есть». А в старом, без use strict, при указании первого аргумента null или undefined в call/apply, функция получает this = window
!Функция сама по себе не запоминает контекст выполнения.
!Чтобы гарантировать правильный контекст для вызова obj.func(), нужно использовать функцию-обёртку, задать её через анонимную функцию либо использовать bind, лучше пользоватся bind-ом она надёжней.
!!!Оператор typeof считает null объектом, это ошибка языка.
!
!Объекты в формате JSON должны быть все в двойных кавычках, в свойствах где ключ-значение последнее допускатеся в числовом и логическом варианте. Ещё не поддерживает коменты.
!В методе JSON.stringify функция replacer работает рекурсивно. То есть, если объект содержит вложенные объекты, массивы и т.п., то все они пройдут через replacer.
!Формат JSON не предусматривает средств для хранения ссылок.
!в методе setTimeout использование строк не рекомендуется, так как они могут вызвать проблемы при минимизации кода, и, вообще, сама возможность использовать строку сохраняется лишь для совместимости. Вместо них использовать анонимные функции.
!в спецификации JavaScript про таймеры нет ни слова. Таймеры – это надстройка над JavaScript, которая описана в секции Timers стандарта HTML5 для браузеров и в документации к Node.JS – для сервера.
!Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval – нет.
!Минимальная задержка таймера по стандарту составляет 4 мс.
!Пользуясь глобальным методом eval при работе с ним не использовать локальные переменные! приводитк к ошибкам.
!Глобальный метод eval опасен при работе с форматом JSON.
!альтернатива eval это new function.
!try..catch работает только в синхронном коде
!try..catch подразумевает, что код синтаксически верен
!В случае, если данные некорректны, JSON.parse генерирует ошибку, то есть скрипт «упадёт». Бывают ситуации, когда без try..catch не обойтись, это – одна из таких.
!В JSON.parse(str) информацию необходимо сначало проверить на ошибки через try..catch.
!В window.onerror можно присвоить функцию, которая выполнится при любой «выпавшей» из скрипта ошибке. Как правило, это используют в информационных целях, например отправляют информацию об ошибке на специальный сервис.
--- Словарик ---
Процесс выполнения скрипта называют «интерпретацией»
Апплет в Jave – это программа на языке Java, которую можно подключить к HTML при помощи тега applet
Спецификация – это самый главный, определяющий документ, в котором написано, как себя ведёт JavaScript, браузер, CSS и т.п.
«Фолдинг» (от англ. folding) – возможность скрыть-раскрыть блок кода.
Операнд – то, к чему применяется оператор.
Унарным называется оператор, который применяется к одному выражению. 
Бинарным называется оператор, который применяется к двум операндам.
конкатенацию - сложение строк
«модальное» означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не разберётся с окном.
итерация - по научному это повторение цикла, если цикл повторяется 3 раза то и будет 3 итерации.
Объявление функций {
    1) Function Declaration – функция, объявленная в основном потоке кода.
    2) Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.
    3) new Funciton - позволяет создавать функцию полностью «на лету» из строки, создаётся вызовом new Function(params, code)
}

Анонимная функция - это функция которая не записывается в переменную, т.е. без имени.
Базис - значение на котором рекурсия заканчивается.
Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.
Динамическое программирование - разбиение сложной задачи на мелкие рещение, которые после объединяются в одно целое решение поставленной задачи.
Метод динамического программирования сверху — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем.
Динамическое программирование снизу включает в себя переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач.
«Named Function Expression» -  особое расширение функциональных выражений (сокращённо NFE) или, по-русски, «именованное функциональное выражение», специально для работы с рекурсией. NFE используется для единственной цели – позволить изнутри функции вызвать саму себя. Такое «специальное» внутреннее имя функции задаётся только в синтаксисе Function Expression.
брейкпойнт / точки останова - 
Автоматизированное тестирование – это когда тесты написаны отдельно от кода, и можно в любой момент запустить их и проверить все важные случаи использования.
Тесты {
    Команды в консоли(node.js + npm) {
    http://mochajs.org/
        $ npm install -g mocha
    http://chaijs.com/
        $ npm install chai
    http://sinonjs.org/ и https://github.com/sinonjs/sinon
        $ npm install sinon
    }
    Тесты BDD – это три в одном: И тесты И документация И примеры использования одновременно. {
        // Задаёт, что именно мы описываем, используется для группировки блоков it    
        describe(название, function() { ... }) 
        // В названии блока it человеческим языком описывается, что должна делать функция, далее следует тест, который проверяет это.
        it(название, function() { ... }) 
        // проверяет
        assert.equal(value1, value2)
    } 
}

Обратный вывод – почти то же самое, что прямой, просто сначала мы обрабатываем следующее значение, а потом текущее.
Односвязный список – это структура данных, которая состоит из элементов, каждый из которых хранит ссылку на следующий. Последний элемент может не иметь ссылки, либо она равна null.
чейнинг (chaining) - подход к написанию кода, цепочкой, в строчку
Статические свойства - это методы и свойства, которые не привязаны к конкретному экземпляру объекта
Фабричный статический метод - так называется статический метод, который служит для создания новых объектов
каррирование – означает создание новой функции путём фиксирования аргументов существующей.
Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция. Декораторы можно не только повторно использовать, но и комбинировать!
«утиная типизация» - проверка не типа а методов или свойств.
Таймеры – это надстройка над JavaScript, которая описана в секции Timers стандарта HTML5 для браузеров и в документации к Node.JS – для сервера.
семантические ошибки - происходящие в корректном коде, в процессе выполнения. Это не синтаксические.
Парсинг – это синтаксический анализ сайтов 


--- Практичные решения разных задач ---
Таймауты и интервалы -> Например, осуществляется анализ и подсветка первых 100 строк, затем через 20 мс – следующие 100 строк и так далее. При этом можно подстраиваться под CPU посетителя: замерять время на анализ 100 строк и, если процессор хороший, то в следующий раз обработать 200 строк, а если плохой – то 50. В итоге подсветка будет работать с адекватной быстротой и без тормозов на любых текстах и компьютерах.

--- Операторы ---
   var - объявление переменных и констант.
   typeof x  - позволяет выяснить, какой тип находится в x, возвращая его в виде строки.


--- Ключевые слова ---
async и defer
--- Директивы ---
use strict
break
continue

---Особые случаи сравнения---
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true!
-
alert( undefined == 0 ); // false! Значение undefined вообще нельзя сравнивать


--- Функции ---
parseInt("11000", 2) - переводит двоичное число в десятичное
n.toString(2) - получает для числа n запись в 2-ной системе в виде строки.



--- Список операторов ---
Оператор                            Использование   Описание
Побитовое И (AND)                   a & b           Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
Побитовое ИЛИ (OR)                  a | b           Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
Побитовое исключающее ИЛИ (XOR)     a ^ b           Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
Побитовое НЕ (NOT)                  ~a              Заменяет каждый бит операнда на противоположный.
Левый сдвиг                         `a << b`        Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
Правый сдвиг, переносящий знак      `a >> b`        Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
Правый сдвиг с заполнением нулями   `a >>> b`       Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.
---



Бинарные побитовые операторы: & | ^ << >> >>>.
Унарный побитовый оператор один: ~.
Как правило, битовое представление числа используется для:
Округления числа: (12.34^0) = 12.
Проверки на равенство -1: if (~n) { n не -1 }.
Упаковки нескольких битововых значений («флагов») в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором &.


--- Модальные окна, синтакс ---
alert(сообщение) //простое сообщение
result = prompt(title, default); //сообщение с полем ввода текста, клавиши "ок" и "отмена"
result = confirm(question); //сообщение с текстом, клавиши "ок" и "отмена"
--- Условаия, синтакс ---
Тернарный оператор
условие ? значение1 : значение2
--- Циклы, синтакс ---
while (условие) { код, тело цикла }
do { тело цикла } while (условие);
for (начало; условие; шаг) {... тело цикла ...}
--- метки в циклах ---
outer:
for(;;) {
    ...
  for(;;) {
    ...
    break outer;
  }
}
--- Сравнения, синтакс ---
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}

--- Функции, синтакс ---
function имя(параметры, через, запятую) {
  код функции
}
--- Создание точки останова или брейкпоинта ---
function pow(x, n) {
  ...
  debugger; // <-- отладчик остановится тут
  ...
}
--- Меню отладчика браузера, гуглхрома ---
Watch Expressions – показывает текущие значения любых выражений.
Call Stack – стек вызовов, все вложенные вызовы, которые привели к текущему месту кода.
Scope Variables – переменные.

### Тесты, синтакс ### 
//консольные команды
--- Тесты --- (node.js + npm)
http://mochajs.org/
    $ npm install -g mocha
http://chaijs.com/
    $ npm install chai
http://sinonjs.org/ и https://github.com/sinonjs/sinon
    $ npm install sinon

    
//c describe,it,assert.equal
describe("pow", function() {

  it("возводит в n-ю степень", function() {
    assert.equal(pow(2, 3), 8);
  });

});


//с функциями before/after и beforeEach/afterEach
describe("Тест", function() {

  before(function() { alert("Начало тестов"); });
  after(function() { alert("Конец тестов"); });

  beforeEach(function() { alert("Вход в тест"); });
  afterEach(function() { alert("Выход из теста"); });

  it('тест 1', function() { alert('1'); });
  it('тест 2', function() { alert('2'); });

});

Вот самые востребованные assert-проверки, встроенные в Chai:
assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false
------------------------------------------------------------------------------------
--- числа ---
!в JavaScript есть обычные числа и три специальных числовых значения: NaN, Infinity и -Infinity.
!Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
!Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
!по общепринятым правилам 5 округляется вверх. 
!Неточность чисел можно исправить либо округлением  до нужного знака, либо приведением числа к целому значению.

Infinity - Бесконечность
    *Бесконечность можно присвоить и в явном виде: var x = Infinity.
    *Бесконечность можно получить, если сделать ну очень большое число
    *Возможна и -бесконечность, -Infinity

функция isNaN(n) - преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.
    *Любая операция с NaN возвращает NaN.
    *Если аргумент isNaN – не число, то он автоматически преобразуется к числу.

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity

Функция parseInt/parseFloat - Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.

Функция toString(основание системы) - для работы с другими системами счисления.
метод toLocaleString() - форматирование

Округления {
Math.floor - Округляет вниз
Math.ceil - Округляет вверх
Math.round - Округляет до ближайшего целого
Округления битовыми операторами (~~,^)
метод num.toFixed(precision) - который округляет число num до точности precision и возвращает результат в виде строки
}

Тригонометрия {
Math.acos(x) - Возвращает арккосинус x (в радианах)
Math.asin(x) - Возвращает арксинус x (в радианах)
Math.atan(x) - Возвращает арктангенс x (в радианах)
Math.atan2(y, x) - Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x) - Вычисляет синус x (в радианах)
Math.cos(x) - Вычисляет косинус x (в радианах)
Math.tan(x) - Возвращает тангенс x (в радианах)
}

Функции общего назначения {
Math.sqrt(x) - Возвращает квадратный корень из x.
Math.log(x) - Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp) - Возводит число в степень, возвращает x(exp)
Math.abs(x) - Возвращает абсолютное значение числа
Math.exp(x) - Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...) - Возвращает наибольший из списка аргументов
Math.min(a, b, c...) - Возвращает наименьший из списка аргументов
Math.random() - Возвращает псевдо-случайное число в интервале [0,1) – то есть между 0(включительно) и 1(не включая). Генератор случайных чисел инициализуется текущим временем.
}

--- Строки ---
!Внутренним форматом строк, вне зависимости от кодировки страницы, является Юникод (Unicode).
!Просто запомните: '~' читается как «не минус один», а "if ~str.indexOf" читается как "если найдено".


Специальные символы {
    \n  перенос строки
    \b  Backspace
    \f  Form feed
    \n  New line
    \r  Carriage return
    \t  Tab
    \'  экранирование ' ковычки
}

-Юникод в HTML-
символ 'а' в виде числовой ссылки: &#1072; Если код хотят дать в 16-ричной системе счисления, то начинают с &#x. Есть много всяких символов: ✂ (&#x2702;) ,½ (&#xBD;), ¾ (&#xBE;) и т.д.

--- Объекты ---
!Есть два средства для проверки наличия свойства в объекте: первое – оператор in, второе – получить его и сравнить с undefined.
!Объекты – это ассоциативные массивы с дополнительными возможностями
!Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).
!При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения.
!arguments - это псевдомассив  то есть объект, который похож на массив, в нём есть нумерованные свойства и length, но методов массива у него нет.
Метод  Object.keys(obj) - для перебора свойств объекта
Копирование свойств объекта - copy(dst, src1, src2…) копирует свойства из объектов src1, src2,... в объект dst. Возвращает получившийся объект.
!!В тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию, вместо работы с arguments организуют передачу данных через объект, который как правило называют options. Возможен и гибридный подход, при котором первый аргумент обязателен, а второй – options, который содержит всевозможные дополнительные параметры
    function showMessage(text, options) {
      // показать сообщение text, настройки показа указаны в options
    }
    
--- Массивы ---
!Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.
!!если у вас элементы массива нумеруются случайно или с большими пропусками, то стоит подумать о том, чтобы использовать обычный объект. Массивы предназначены именно для работы с непрерывной упорядоченной коллекцией элементов.
!При уменьшении свойства length массив укорачивается.
Цикл по ключам: for (key in obj).
!Массивы существуют для работы с упорядоченным набором элементов.
!Массиву не стоит назначать строковые свойства (пример: arr.test = 5), то есть, работать именно как с массивом, а не как с объектом, иначе интерпретатор будет его обрабатывать как объект.

Метод split     | split(s) | позволяет превратить строку в массив, разбив ее по разделителю s.
Метод join      | arr.join(str) | Он берет массив и склеивает его в строку, используя str как разделитель.
Метод splice    | arr.splice(index[, deleteCount, elem1, ..., elemN]) | удалять элементы, вставлять элементы, заменять элементы, по очереди и одновременно.
Метод slice     | slice(begin, end) | копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется. Также работает со строками.
Метод sort      | arr.sort(fn) | сортирует, можно со своей функцией сортировки
Метод reverse   | arr.reverse() | меняет порядок элементов в массиве на обратный. %перевернуть массив
Метод concat    | arr.concat(value1, value2, … valueN) | создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
Метод indexOf/  | arr.indexOf(searchElement[, fromIndex]) | возвращает номер элемента searchElement в массиве arr или -1, если его нет. В IE-8 нужна библиотека ES5-shim. Метод работает как перебор(for).
Метод lastIndexOf | arr.lastIndexOf(searchElement[, fromIndex]) | ищет справа-налево: с конца массива или с номера fromIndex, если он указан. В IE-8 нужна библиотека ES5-shim. Метод работает как перебор(for).

--- Перебирающие метды ---

callback(item, i, arr)
    item – очередной элемент массива.
    i – его номер.
    arr – массив, который перебирается.

Перебирающие метды forEach | arr.forEach(callback[, thisArg]) | Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.

Перебирающие метды filter | arr.filter(callback[, thisArg]) | используется для фильтрации массива через функцию. Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.

Перебирающие метды map | arr.map(callback[, thisArg]) | используется для трансформации массива.

Перебирающие метды | arr.every(callback[, thisArg]) | возвращает true, если вызов callback вернёт true для каждого элемента arr.

Перебирающие метды | arr.some(callback[, thisArg]) | возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.




Аргументы функции callback(previousValue, currentItem, index, arr):
    previousValue – последний результат вызова функции, он же «промежуточный результат».
    currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
    index – номер текущего элемента.
    arr – обрабатываемый массив.

Перебирающие метды reduce | arr.reduce(callback[, initialValue]) | используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата. C лева на право. Где callback(previousValue, currentItem, index, arr).

Перебирающие метды reduceRight | arr.reduceRight(callback[, initialValue]) | используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата. C права не лево. Где callback(previousValue, currentItem, index, arr).



--- Дата и время ---
!Все современные браузеры, включая IE9+, понимают даты в упрощённом формате ISO 8601 Extended.
Этот формат выглядит так: YYYY-MM-DDTHH:mm:ss.sssZ, где:
!Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее.
!Для получения текущей даты в миллисекундах лучше использовать Date.now(), чтобы не создавать лишний объект Date (кроме IE8-)

YYYY-MM-DD – дата в формате год-месяц-день.
Обычный символ T используется как разделитель.
HH:mm:ss.sss – время: часы-минуты-секунды-миллисекунды.
Часть 'Z' обозначает временную зону – в формате +-hh:mm, либо символ Z, обозначающий UTC. По стандарту её можно не указывать, тогда UTC, но в Safari с этим ошибка, так что лучше указывать всегда.


-объект Date-
    new Date() - Создает объект Date с текущей датой и временем
    new Date(milliseconds) - Создает объект Date, значение которого равно количеству миллисекунд прошедших с 1 января 1970 года GMT+0.
    new Date(datestring) - позволяет выбрать из объекта Date 1 из аргументов (year, month, date, hours, minutes, seconds, ms)

-Методы-
    getFullYear() / getUTCFullYear() - Получить год(из 4 цифр)
    getMonth() / getUTCMonth() - Получить месяц, от 0 до 11.
    getDate() / getUTCDate() - Получить число месяца, от 1 до 31.
    getHours() / getUTCHours() - Получить соответствующие компоненты. 
    getMinutes() / getUTCMinutes() - Получить соответствующие компоненты. 
    getSeconds() / getUTCSeconds() - Получить соответствующие компоненты.
    getMilliseconds() / getUTCMilliseconds() - Получить соответствующие компоненты.
    getDay() / getUTCDay() - получить день недели
    getTime() - Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0
    getTimezoneOffset() - Возвращает разницу между местным и UTC-временем, в минутах.

-Установка времени-
    setFullYear(year [, month, date])
    setMonth(month [, date])
    setDate(date)
    setHours(hour [, min, sec, ms])
    setMinutes(min [, sec, ms])
    setSeconds(sec [, ms])
    setMilliseconds(ms)
    setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)
    Все они, кроме setTime(), обладают также UTC-вариантом, например: setUTCHours().

performance.now() возвращает количество миллисекунд, прошедшее с начала загрузки страницы.
console.time(метка) – включить внутренний хронометр браузера с меткой.
console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.


-Методы вывода без локализации-
    Возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Есть формат и UTC.
    toString()
    toDateString()
    toTimeString()
    toISOString()

Метод Date.parse(str) разбирает строку str в таком формате и возвращает соответствующее ей количество миллисекунд.
Метод Date.now() возвращает дату сразу в виде миллисекунд. Технически, он аналогичен вызову +new Date(), но в отличие от него не создаёт промежуточный объект даты, а поэтому – во много раз быстрее.


--- Замыкания ---
Cтатическими переменными - свойства, привязанные к функции
Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.

!В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» (global object).
!Все переменные и параметры функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при каждом её запуске. Называют ещё "лексическое окружение" или просто "объект переменных".
!Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.

!Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции». А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».
!Свойство объекта доступно всем у кого есть объект функции

window - (global object) открытый, глобальный объект.
LexicalEnvironment - (объект переменных) скрытый объект. Хранит содержимое функции
[[Scope]] - (Ско́уп) скрытое свойство функции. Это ссылки на объекты(внутр и внеш) с переменными.

-ИНИЦИАЛИЗАЦИЯ-
инициализация (1-подготовка где каждое объявление добавляется в window, 2-выполнение)
  1.1) Сканируется на предмет объявления функций вида Function Declaration,
  1.2) Сканируется на предмет объявления переменных var. 

  2.1) Присваивание (=) значений переменных происходит, когда поток выполнения доходит до соответствующей строчки кода, до этого они undefined.



### дескрипторы ###

Object.defineProperty(obj, prop, descriptor) - Добавление и изменение свойстВА объекта.
    -> Аргументы: 
    obj - Объект, в котором объявляется свойство.
    prop - Имя свойства, которое нужно объявить или модифицировать.
    descriptor - Дескриптор – объект, который описывает поведение свойства.
        -> descriptor может иметь следующие значения:
        1. value – значение свойства, по умолчанию undefined
        2. writable – значение свойства можно менять, если true. По умолчанию false.
        3. configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.
        4. enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
        5. get – функция, которая возвращает значение свойства. По умолчанию undefined.
        6. set – функция, которая записывает значение свойства. По умолчанию undefined.

Object.defineProperties(obj, descriptors) - Добавление свойстВ объекту.

Object.keys(obj) - Возвращает только enumerable-свойства.
    Где enumerable одно из значений descriptor:
        enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.

Object.getOwnPropertyNames(obj) - Возращает массив всех свойств.

Object.getOwnPropertyDescriptor(obj, prop) - Возвращает дескриптор для свойства obj[prop].

Object.preventExtensions(obj) - Запрещает добавление свойств в объект.

Object.seal(obj) - Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.

Object.freeze(obj) - Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.

Object.isExtensible(obj) - Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.

Object.isSealed(obj) - Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.

Object.isFrozen(obj) - Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.


















































































































































































































































































